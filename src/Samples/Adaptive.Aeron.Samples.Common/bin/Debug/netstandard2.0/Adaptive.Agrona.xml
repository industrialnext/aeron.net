<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Adaptive.Agrona</name>
    </assembly>
    <members>
        <member name="T:Adaptive.Agrona.BitUtil">
            <summary>
            Miscellaneous useful functions for dealing with low level bits and bytes.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.BitUtil.SIZE_OF_BYTE">
            <summary>
            Size of a byte in bytes
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.BitUtil.SIZE_OF_BOOLEAN">
            <summary>
            Size of a boolean in bytes
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.BitUtil.SIZE_OF_CHAR">
            <summary>
            Size of a char in bytes
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.BitUtil.SIZE_OF_SHORT">
            <summary>
            Size of a short in bytes
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.BitUtil.SIZE_OF_INT">
            <summary>
            Size of an int in bytes
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.BitUtil.SIZE_OF_FLOAT">
            <summary>
            Size of a a float in bytes
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.BitUtil.SIZE_OF_LONG">
            <summary>
            Size of a long in bytes
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.BitUtil.SIZE_OF_DOUBLE">
            <summary>
            Size of a double in bytes
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.BitUtil.CACHE_LINE_LENGTH">
            <summary>
            Length of the data blocks used by the CPU cache sub-system in bytes.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.FindNextPositivePowerOfTwo(System.Int32)">
            <summary>
            Fast method of finding the next power of 2 greater than or equal to the supplied value.
            
            If the value is &lt;= 0 then 1 will be returned.
            
            This method is not suitable for <seealso cref="F:System.Int32.MinValue"/> or numbers greater than 2^30.
            </summary>
            <param name="value"> from which to search for next power of 2 </param>
            <returns> The next power of 2 or the value itself if it is a power of 2 </returns>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.Align(System.Int32,System.Int32)">
            <summary>
            Align a value to the next multiple up of alignment.
            If the value equals an alignment multiple then it is returned unchanged.
            <para>
            This method executes without branching. This code is designed to be use in the fast path and should not
            be used with negative numbers. Negative numbers will result in undefined behaviour.
            
            </para>
            </summary>
            <param name="value">     to be aligned up. </param>
            <param name="alignment"> to be used. </param>
            <returns> the value aligned to the next boundary. </returns>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.FromHexByteArray(System.Byte[])">
            <summary>
            Generate a byte array from the hex representation of the given byte array.
            </summary>
            <param name="buffer"> to convert from a hex representation (in Big Endian) </param>
            <returns> new byte array that is decimal representation of the passed array </returns>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.ToHexByteArray(System.Byte[])">
            <summary>
            Generate a byte array that is a hex representation of a given byte array.
            </summary>
            <param name="buffer"> to convert to a hex representation </param>
            <returns> new byte array that is hex representation (in Big Endian) of the passed array </returns>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.ToHexByteArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate a byte array that is a hex representation of a given byte array.
            </summary>
            <param name="buffer"> to convert to a hex representation </param>
            <param name="offset"> the offset into the buffer </param>
            <param name="length"> the number of bytes to convert </param>
            <returns> new byte array that is hex representation (in Big Endian) of the passed array </returns>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.FromHex(System.String)">
            <summary>
            Generate a byte array from a string that is the hex representation of the given byte array.
            </summary>
            <param name="value"> to convert from a hex representation (in Big Endian) </param>
            <returns> new byte array holding the decimal representation of the passed array </returns>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.ToHex(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate a string that is the hex representation of a given byte array.
            </summary>
            <param name="buffer"> to convert to a hex representation </param>
            <param name="offset"> the offset into the buffer </param>
            <param name="length"> the number of bytes to convert </param>
            <returns> new String holding the hex representation (in Big Endian) of the passed array </returns>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.ToHex(System.Byte[])">
            <summary>
            Generate a string that is the hex representation of a given byte array.
            </summary>
            <param name="buffer"> to convert to a hex representation </param>
            <returns> new String holding the hex representation (in Big Endian) of the passed array </returns>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.IsEven(System.Int32)">
            <summary>
            Is a number even.
            </summary>
            <param name="value"> to check. </param>
            <returns> true if the number is even otherwise false. </returns>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.IsPowerOfTwo(System.Int32)">
            <summary>
            Is a value a positive power of two.
            </summary>
            <param name="value"> to be checked. </param>
            <returns> true if the number is a positive power of two otherwise false. </returns>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.Next(System.Int32,System.Int32)">
            <summary>
            Cycles indices of an array one at a time in a forward fashion
            </summary>
            <param name="current"> value to be incremented. </param>
            <param name="max">     value for the cycle. </param>
            <returns> the next value, or zero if max is reached. </returns>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.Previous(System.Int32,System.Int32)">
            <summary>
            Cycles indices of an array one at a time in a backwards fashion
            </summary>
            <param name="current"> value to be decremented. </param>
            <param name="max">     value of the cycle. </param>
            <returns> the next value, or max - 1 if current is zero </returns>
        </member>
        <member name="M:Adaptive.Agrona.BitUtil.IsAligned(System.Int64,System.Int32)">
            <summary>
            Is an address aligned on a boundary.
            </summary>
            <param name="address">   to be tested. </param>
            <param name="alignment"> boundary the address is tested against. </param>
            <returns> true if the address is on the aligned boundary otherwise false. </returns>
            <exception cref="T:System.ArgumentException"> if the alignment is not a power of 2` </exception>
        </member>
        <member name="T:Adaptive.Agrona.BufferUtil">
            <summary>
            Common functions for buffer implementations.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.BufferUtil.BoundsCheck(System.Byte[],System.Int64,System.Int32)">
            <summary>
            Bounds check the access range and throw a <seealso cref="T:System.IndexOutOfRangeException"/> if exceeded.
            </summary>
            <param name="buffer"> to be checked. </param>
            <param name="index">  at which the access will begin. </param>
            <param name="length"> of the range accessed. </param>
        </member>
        <member name="F:Adaptive.Agrona.ByteOrder.BigEndian">
            <summary>
            Constant denoting big-endian byte order.  In this order, the bytes of a
            multibyte value are ordered from most significant to least significant.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.ByteOrder.LittleEndian">
            <summary>
            Constant denoting little-endian byte order.  In this order, the bytes of
            a multibyte value are ordered from least significant to most
            significant.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.CloseHelper.QuietDispose(System.IDisposable)">
            <summary>
            Quietly close a <seealso cref="T:System.IDisposable"/> dealing with nulls and exceptions.
            </summary>
            <param name="disposable"> to be disposed. </param>
        </member>
        <member name="M:Adaptive.Agrona.CloseHelper.QuietDispose(System.Action)">
            <summary>
            Quietly close a <seealso cref="T:System.IDisposable"/> dealing with nulls and exceptions.
            </summary>
            <param name="disposable"> to be disposed. </param>
        </member>
        <member name="M:Adaptive.Agrona.CloseHelper.Dispose(Adaptive.Agrona.ErrorHandler,System.IDisposable)">
            <summary>
            Dispose an <see cref="T:System.IDisposable"/> delegating exceptions to <see cref="T:Adaptive.Agrona.ErrorHandler"/>.
            </summary>
            <param name="errorHandler"> to delegate exceptions to.</param>
            <param name="disposable"> to be closed.</param>
        </member>
        <member name="M:Adaptive.Agrona.CloseHelper.Dispose(Adaptive.Agrona.ErrorHandler,System.Action)">
            <summary>
            Dispose an <see cref="T:System.IDisposable"/> delegating exceptions to <see cref="T:Adaptive.Agrona.ErrorHandler"/>.
            </summary>
            <param name="errorHandler"> to delegate exceptions to.</param>
            <param name="disposable"> to be closed.</param>
        </member>
        <member name="T:Adaptive.Agrona.Collections.ArrayUtil">
            <summary>
            Utility class for operating on arrays as if they were collections. This is useful for
            critical paths where operations like add and remove are seldom used, but iterating
            is common and checkcast and indirection are comparatively expensive.
            
            In all cases the array being mutated is assumed to be full.
            
            In all cases reference equality is used.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Collections.ArrayUtil.Add``1(``0[],``0)">
            <summary>
            Add an element to an array resulting in a new array.
            </summary>
            <param name="oldElements">  to have the new element added. </param>
            <param name="elementToAdd"> for the new array. </param>
            <returns> a new array that is one bigger and containing the new element at the end. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Collections.ArrayUtil.Remove``1(``0[],``0)">
            <summary>
            Remove an element from an array resulting in a new array if the element was found otherwise the old array.
            
            Returns its input parameter if the element to remove isn't a member.
            </summary>
            <param name="oldElements">     to have the element removed from. </param>
            <param name="elementToRemove"> being searched for by identity semantics. </param>
            <returns> a new array without the element if found otherwise the original array. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Collections.ArrayUtil.NewArray``1(``0[],System.Int32)">
            <summary>
            Allocate a new array of the same type as another array.
            </summary>
            <param name="oldElements"> on which the new array is based. </param>
            <param name="length">      of the new array. </param>
            <returns>            the new array of requested length. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Collections.ArrayUtil.EnsureCapacity``1(``0[],System.Int32)">
            <summary>
            Ensure an array has the required capacity. Resizing only if needed.
            </summary>
            <param name="oldElements">    to ensure that are long enough. </param>
            <param name="requiredLength"> to ensure. </param>
            <returns>               an array of the required length. </returns>
        </member>
        <member name="T:Adaptive.Agrona.Collections.CollectionUtil">
            <summary>
            Utility functions for collection objects.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Collections.CollectionUtil.GetOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            A getOrDefault that doesn't create garbage if its suppler is non-capturing.
            </summary>
            <param name="map"> to perform the lookup on. </param>
            <param name="key"> on which the lookup is done. </param>
            <param name="supplier"> of the default value if one is not found. </param>
            <returns> the value if found or a new default which as been added to the map. </returns>
        </member>
        <member name="T:Adaptive.Agrona.Collections.IntObjConsumer`1">
            <summary>
            This is an (int, Object) primitive specialisation of a BiConsumer.
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.Collections.ListUtil">
            <summary>
            Utility functions for working with <see cref="T:System.Collections.Generic.List`1"/>
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Collections.ListUtil.FastUnorderedRemove``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>
            Removes element at index i, but instead of copying all elements to the left, moves into the same slot the last
            element. This avoids the copy costs, but spoils the list order. If i is the last element it is just removed.
            </summary>
            <param name="list">      to be modified.</param>
            <param name="i">         removal index.</param>
            <param name="lastIndex"> last element index.</param>
            <typeparam name="T">     element type.</typeparam>
            <exception cref="T:System.IndexOutOfRangeException"> if i or lastIndex are out of bounds.</exception>
        </member>
        <member name="M:Adaptive.Agrona.Collections.ListUtil.FastUnorderedRemove``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            Removes element but instead of copying all elements to the left, moves into the same slot the last element.
            This avoids the copy costs, but spoils the list order. If e is the last element it is just removed.
            </summary>
            <param name="list">      to be modified.</param>
            <param name="e">         to be removed.</param>
            <typeparam name="T">     element type.</typeparam>
            <returns> true if found and removed, false otherwise.</returns>
        </member>
        <member name="T:Adaptive.Agrona.Collections.Map`2">
            <summary>
            A map implementation that replicates the behaviour of the Java equivalent.
            </summary>
            <typeparam name="TKey">The type of the keys in the map.</typeparam>
            <typeparam name="TValue">The type of the values in the map.</typeparam>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.AgentInvoker">
            <summary>
            <see cref="M:Adaptive.Agrona.Concurrent.AgentInvoker.Agent"/> container which does not start a thread. It instead allows the duty ctyle <see cref="M:Adaptive.Agrona.Concurrent.IAgent.DoWork"/> to be
            invoked directly.
            
            Exceptions which occur during the <see cref="M:Adaptive.Agrona.Concurrent.IAgent.DoWork"/> invocation will be caught and passed to the provided <see cref="T:Adaptive.Agrona.ErrorHandler"/>.
            
            <b>Note: </b> This class is not threadsafe.
            
            </summary>
        </member>
        <member name="P:Adaptive.Agrona.Concurrent.AgentInvoker.IsClosed">
            <summary>
            Has the <see cref="T:Adaptive.Agrona.Concurrent.IAgent"/> been closed?
            </summary>
        </member>
        <member name="P:Adaptive.Agrona.Concurrent.AgentInvoker.IsStarted">
            <summary>
            Has the <see cref="T:Adaptive.Agrona.Concurrent.IAgent"/> been started?
            </summary>
        </member>
        <member name="P:Adaptive.Agrona.Concurrent.AgentInvoker.IsRunning">
            <summary>
            Has the <see cref="T:Adaptive.Agrona.Concurrent.IAgent"/> been running?
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AgentInvoker.#ctor(Adaptive.Agrona.ErrorHandler,Adaptive.Agrona.Concurrent.Status.AtomicCounter,Adaptive.Agrona.Concurrent.IAgent)">
            <summary>
            Create an agent and initialise it.
            </summary>
            <param name="errorHandler"> to be called if an <seealso cref="T:System.Exception"/> is encountered </param>
            <param name="errorCounter"> to be incremented each time an exception is encountered. This may be null. </param>
            <param name="agent">        to be run in this thread. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AgentInvoker.Agent">
            <summary>
            The <see cref="M:Adaptive.Agrona.Concurrent.AgentInvoker.Agent"/> which is contained.
            </summary>
            <returns> <see cref="M:Adaptive.Agrona.Concurrent.AgentInvoker.Agent"/> being contained.</returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AgentInvoker.Start">
            <summary>
            Mark the invoker as started and call the <seealso cref="M:Adaptive.Agrona.Concurrent.IAgent.OnStart"/> method.
            <para>
            Startup logic will only be performed once.
            </para>
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AgentInvoker.Invoke">
            <summary>
            Invoke the <seealso cref="M:Adaptive.Agrona.Concurrent.IAgent.DoWork"/> method and return the work count.
            
            If an error occurs then the <seealso cref="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.Increment"/> will be called on the errorCounter if not null
            and the <seealso cref="T:System.Exception"/> will be passed to the <seealso cref="T:Adaptive.Agrona.ErrorHandler"/> method. If the error
            is an <seealso cref="T:Adaptive.Agrona.Concurrent.AgentTerminationException"/> then <seealso cref="M:Adaptive.Agrona.Concurrent.AgentInvoker.Dispose"/> will be called after the error handler.
            
            If not successfully started or after closed then this method will return without invoking the <seealso cref="M:Adaptive.Agrona.Concurrent.AgentInvoker.Agent"/>.
                
            </summary>
            <returns> the work count for the <seealso cref="M:Adaptive.Agrona.Concurrent.IAgent.DoWork"/> method. </returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.AgentRunner">
            <summary>
            Agent runner containing an <see cref="T:Adaptive.Agrona.Concurrent.IAgent"/> which is run on a <see cref="M:Adaptive.Agrona.Concurrent.AgentRunner.Thread"/>.
            <para>
            Note: An instance should only be started once and then discarded, it should not be reused.
            </para>
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.AgentRunner.TOMBSTONE">
            <summary>
            Indicates that the runner is being closed.
            </summary>
        </member>
        <member name="P:Adaptive.Agrona.Concurrent.AgentRunner.IsClosed">
            <summary>
            Has the <see cref="T:Adaptive.Agrona.Concurrent.IAgent"/> been closed?
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AgentRunner.#ctor(Adaptive.Agrona.Concurrent.IIdleStrategy,Adaptive.Agrona.ErrorHandler,Adaptive.Agrona.Concurrent.Status.AtomicCounter,Adaptive.Agrona.Concurrent.IAgent)">
            <summary>
            Create an agent runner and initialise it.
            </summary>
            <param name="idleStrategy"> to use for Agent run loop </param>
            <param name="errorHandler"> to be called if an <seealso cref="T:System.Exception"/> is encountered </param>
            <param name="errorCounter"> to be incremented each time an exception is encountered. This may be null.</param>
            <param name="agent">        to be run in this thread. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AgentRunner.StartOnThread(Adaptive.Agrona.Concurrent.AgentRunner)">
            <summary>
            Start the given agent runner on a new thread.
            </summary>
            <param name="runner"> the agent runner to start </param>
            <returns>  the new thread that has been started.</returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AgentRunner.StartOnThread(Adaptive.Agrona.Concurrent.AgentRunner,Adaptive.Agrona.Concurrent.IThreadFactory)">
            <summary>
            Start the given agent runner on a new thread.
            </summary>
            <param name="runner"> the agent runner to start </param>
            <param name="threadFactory"> the factory to use to create the thread.</param>
            <returns>  the new thread that has been started.</returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AgentRunner.Agent">
            <summary>
            The <seealso cref="T:Adaptive.Agrona.Concurrent.IAgent"/> which is contained.
            </summary>
            <returns> <seealso cref="T:Adaptive.Agrona.Concurrent.IAgent"/> being contained.</returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AgentRunner.Run">
            <summary>
            Run an <seealso cref="T:Adaptive.Agrona.Concurrent.IAgent"/>.
            <para>
            This method does not return until the run loop is stopped via <seealso cref="M:Adaptive.Agrona.Concurrent.AgentRunner.Dispose"/>.
            </para>
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AgentRunner.Dispose">
            <summary>
            Stop the running Agent and cleanup. This will wait for the work loop to exit and the <seealso cref="T:Adaptive.Agrona.Concurrent.IAgent"/> performing
            it <seealso cref="M:Adaptive.Agrona.Concurrent.IAgent.OnClose"/> logic.
            <para>
            The clean up logic will only be performed once even if close is called from multiple concurrent threads.
            </para>
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AtomicBoolean.CompareAndSet(System.Boolean,System.Boolean)">
            <summary>
            Atomically set the value to the given updated value if the current value equals the comparand
            </summary>
            <param name="newValue">The new value</param>
            <param name="comparand">The comparand (expected value)</param>
            <returns></returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AtomicLong.Get">
            <summary>
            Gets the current value.
            </summary>
            <returns> the current value.</returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AtomicLong.LazySet(System.Int64)">
            <summary>
            Eventually sets to the given value.
            </summary>
            <param name="newValue"> the new value.</param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AtomicLong.IncrementAndGet">
            <summary>
            Atomically increments the current value
            </summary>
            <returns> the udpated value.</returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AtomicReference`1.Get">
            <summary>
            Gets the current value.
            </summary>
            <returns> the current value.</returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.AtomicReference`1.LazySet(`0)">
            <summary>
            Eventually sets to the given value.
            </summary>
            <param name="newValue"> the new value.</param>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.BackoffIdleStrategy">
            <summary>
            Idling strategy for threads when they have no work to do.
            
            Spin for maxSpins, then
            <see cref="M:System.Threading.Thread.Yield"/> for maxYields, then
            <see cref="M:System.Threading.Thread.Sleep(System.Int32)"/> on an exponential backup to maxParkPeriodMs
            </summary>
            TODO Padding to avoid false sharing
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.BackoffIdleStrategy.#ctor(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Create a set of state tracking idle behavior
            </summary>
            <param name="maxSpins"> to perform before moving to <see cref="M:System.Threading.Thread.Yield"/></param>
            <param name="maxYields"> to perform before moving to <see cref="M:System.Threading.Thread.Sleep(System.Int32)"/></param>
            <param name="minParkPeriodMs"> to use when initating parkiing</param>
            <param name="maxParkPeriodMs"> to use when parking</param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.BackoffIdleStrategy.Idle(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.BackoffIdleStrategy.Idle">
            <inheritdoc />
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.BackoffIdleStrategy.Reset">
            <inheritdoc />
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Broadcast.BroadcastBufferDescriptor">
            <summary>
            Layout of the broadcast buffer. The buffer consists of a ring of messages that is a power of 2 in size.
            This is followed by a trailer section containing state information about the ring.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Broadcast.BroadcastBufferDescriptor.TailIntentCounterOffset">
            <summary>
            Offset within the trailer for where the tail intended value is stored. 
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Broadcast.BroadcastBufferDescriptor.TailCounterOffset">
            <summary>
            Offset within the trailer for where the tail value is stored. 
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Broadcast.BroadcastBufferDescriptor.LatestCounterOffset">
            <summary>
            Offset within the trailer for where the latest sequence value is stored. 
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Broadcast.BroadcastBufferDescriptor.TrailerLength">
            <summary> 
            Total size of the trailer 
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastBufferDescriptor.CheckCapacity(System.Int32)">
            <summary>
            Check the the buffer capacity is the correct size.
            </summary>
            <param name="capacity"> to be checked. </param>
            <exception cref="T:System.InvalidOperationException"> if the buffer capacity is not a power of 2. </exception>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver">
            <summary>
            Receive messages broadcast from a BroadcastTransmitter via an underlying buffer. Receivers can join
            a transmission stream at any point by consuming the latest message at the point of joining and forward.
            <para>
            If a Receiver cannot keep up with the transmission stream then loss will be experienced. Loss is not an
            error condition.
            </para>
            <para>
            <b>Note:</b> Each Receiver is not threadsafe but there can be zero or many receivers to a transmission stream.
            </para>
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.#ctor(Adaptive.Agrona.Concurrent.IAtomicBuffer)">
            <summary>
            Construct a new broadcast receiver based on an underlying <seealso cref="T:Adaptive.Agrona.Concurrent.IAtomicBuffer"/>.
            The underlying buffer must a power of 2 in size plus sufficient space
            for the <seealso cref="F:Adaptive.Agrona.Concurrent.Broadcast.BroadcastBufferDescriptor.TrailerLength"/>.
            </summary>
            <param name="buffer"> via which messages will be exchanged. </param>
            <exception cref="T:System.InvalidOperationException"> if the buffer capacity is not a power of 2
            plus <seealso cref="F:Adaptive.Agrona.Concurrent.Broadcast.BroadcastBufferDescriptor.TrailerLength"/> in capacity. </exception>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.Capacity">
            <summary>
            Get the capacity of the underlying broadcast buffer.
            </summary>
            <returns> the capacity of the underlying broadcast buffer. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.LappedCount">
            <summary>
            Get the number of times the transmitter has lapped this receiver around the buffer. On each lap
            as least a buffer's worth of loss will be experienced.
            <para>
            <b>Note:</b> This method is threadsafe for calling from an external monitoring thread.
            
            </para>
            </summary>
            <returns> the capacity of the underlying broadcast buffer. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.TypeId">
            <summary>
            Type of the message received.
            </summary>
            <returns> typeId of the message received. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.Offset">
            <summary>
            The offset for the beginning of the next message in the transmission stream.
            </summary>
            <returns> offset for the beginning of the next message in the transmission stream. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.Length">
            <summary>
            The length of the next message in the transmission stream.
            </summary>
            <returns> length of the next message in the transmission stream. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.Buffer">
            <summary>
            The underlying buffer containing the broadcast message stream.
            </summary>
            <returns> the underlying buffer containing the broadcast message stream. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.ReceiveNext">
            <summary>
            Non-blocking receive of next message from the transmission stream.
            <para>
            If loss has occurred then <seealso cref="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.LappedCount"/> will be incremented.
            
            </para>
            </summary>
            <returns> true if transmission is available with <seealso cref="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.Offset"/>, <seealso cref="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.Length"/> and <seealso cref="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.TypeId"/>
            set for the next message to be consumed. If no transmission is available then false. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver.Validate">
            <summary>
            Validate that the current received record is still valid and has not been overwritten.
            <para>
            If the receiver is not consuming messages fast enough to keep up with the transmitter then loss
            can be experienced resulting in messages being overwritten thus making them no longer valid.
            
            </para>
            </summary>
            <returns> true if still valid otherwise false. </returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Broadcast.CopyBroadcastReceiver">
            <summary>
            Receiver that copies messages which have been broadcast to enable a simpler API for the client.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Broadcast.CopyBroadcastReceiver.ScratchBufferSize">
            <summary>
            Default length for the scratch buffer for copying messages into.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.CopyBroadcastReceiver.#ctor(Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver,System.Int32)">
            <summary>
            Wrap a <seealso cref="T:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver"/> to simplify the API for receiving messages.
            </summary>
            <param name="receiver"> to be wrapped. </param>
            <param name="scratchBufferLength">  is the maximum length of a message to be copied when receiving.</param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.CopyBroadcastReceiver.#ctor(Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver)">
            <summary>
            Wrap a <seealso cref="T:Adaptive.Agrona.Concurrent.Broadcast.BroadcastReceiver"/> to simplify the API for receiving messages.
            </summary>
            <param name="receiver"> to be wrapped. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.CopyBroadcastReceiver.Receive(Adaptive.Agrona.Concurrent.MessageHandler)">
            <summary>
            Receive one message from the broadcast buffer.
            </summary>
            <param name="handler"> to be called for each message received. </param>
            <returns> the number of messages that have been received. </returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Broadcast.RecordDescriptor">
            <summary>
            Description of the structure for a record in the broadcast buffer.
            All messages are stored in records with the following format.
            
            <pre>
              0                   1                   2                   3
              0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |R|                        Length                               |
             +-+-------------------------------------------------------------+
             |                           Type                                |
             +---------------------------------------------------------------+
             |                       Encoded Message                        ...
            ...                                                              |
             +---------------------------------------------------------------+
            </pre>
            
            (R) bits are reserved.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Broadcast.RecordDescriptor.PaddingMsgTypeID">
            <summary>
            Message type is padding to prevent fragmentation in the buffer. </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Broadcast.RecordDescriptor.LengthOffset">
            <summary>
            Offset within the record at which the record length field begins. </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Broadcast.RecordDescriptor.TypeOffset">
            <summary>
            Offset within the record at which the message type field begins. </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Broadcast.RecordDescriptor.HeaderLength">
            <summary>
            Length of the record header in bytes. </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Broadcast.RecordDescriptor.RecordAlignment">
            <summary>
            Alignment as a multiple of bytes for each record. </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.RecordDescriptor.CalculateMaxMessageLength(System.Int32)">
            <summary>
            Calculate the maximum supported message length for a buffer of given capacity.
            </summary>
            <param name="capacity"> of the log buffer. </param>
            <returns> the maximum supported size for a message. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.RecordDescriptor.GetLengthOffset(System.Int32)">
            <summary>
            The buffer offset at which the message length field begins.
            </summary>
            <param name="recordOffset"> at which the frame begins. </param>
            <returns> the offset at which the message length field begins. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.RecordDescriptor.GetTypeOffset(System.Int32)">
            <summary>
            The buffer offset at which the message type field begins.
            </summary>
            <param name="recordOffset"> at which the frame begins. </param>
            <returns> the offset at which the message type field begins. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.RecordDescriptor.GetMsgOffset(System.Int32)">
            <summary>
            The buffer offset at which the encoded message begins.
            </summary>
            <param name="recordOffset"> at which the frame begins. </param>
            <returns> the offset at which the encoded message begins. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Broadcast.RecordDescriptor.CheckTypeId(System.Int32)">
            <summary>
            Check that and message id is in the valid range.
            </summary>
            <param name="msgTypeId"> to be checked. </param>
            <exception cref="T:System.ArgumentException"> if the id is not in the valid range. </exception>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.BusySpinIdleStrategy">
            <summary>
            Busy spin strategy targeted at lowest possible latency. This strategy will monopolise a thread to achieve the lowest
            possible latency. Useful for creating bubbles in the execution pipeline of tight busy spin loops with no other logic 
            than status checks on progress.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.BusySpinIdleStrategy.Idle(System.Int32)">
            <summary>
            <b>Note</b>: this implementation will result in no safepoint poll once inlined.
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.CompositeAgent">
            <summary>
            Group several <see cref="T:Adaptive.Agrona.Concurrent.IAgent"/> into one composite so they can be scheduled as a unit.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.CompositeAgent.#ctor(System.Collections.Generic.List{Adaptive.Agrona.Concurrent.IAgent})">
            <param name="agents"> the parts of this composite, at least one agent and no null agents allowed</param>
            <exception cref="T:System.ArgumentException"> if an empty array of agents is provided</exception>
            <exception cref="T:System.NullReferenceException"> if the array or any element is null</exception>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.CompositeAgent.#ctor(Adaptive.Agrona.Concurrent.IAgent[])">
            <param name="agents"> the parts of this composite, at least one agent and no null agents allowed</param>
            <exception cref="T:System.ArgumentException"> if an empty array of agents is provided</exception>
            <exception cref="T:System.NullReferenceException"> if the array or any element is null</exception>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.CompositeAgent.RoleName">
            <inheritdoc />
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.CompositeAgent.OnStart">
            <inheritdoc />
            Note that one agent throwing an exception on start may result in other agents not being started.
            
            <exception cref="T:System.Exception"> if any sub-agent throws an exception onClose. The first agent exception is collected as the inner exception of the thrown exception. </exception>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.CompositeAgent.DoWork">
            <inheritdoc />
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.CompositeAgent.OnClose">
            <inheritdoc />
            Note that one agent throwing an exception on close will not prevent other agents from being closed.
            
            <exception cref="T:System.Exception"> if any sub-agent throws an exception onClose. The first agent exception is collected as the inner exception of the thrown exception. </exception>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Configuration.IDLE_MAX_SPINS">
            <summary>
            Spin on no activity before backing off to yielding.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Configuration.IDLE_MAX_YIELDS">
            <summary>
            Yield the thread so others can run before backing off to parking.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Configuration.IDLE_MIN_PARK_MS">
            <summary>
            Park for the minimum period of time which is typically 50-55 microseconds on 64-bit non-virtualised Linux.
            You will typically get 50-55 microseconds plus the number of nanoseconds requested if a core is available.
            On Windows expect to wait for at least 16ms or 1ms if the high-res timers are enabled.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Configuration.IDLE_MAX_PARK_MS">
            <summary>
            Maximum back-off park time which doubles on each interval stepping up from the min park idle.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.ControllableIdleStrategy.Idle(System.Int32)">
            <summary>
            Idle based on current status indication value
            </summary>
            <param name="workCount"> performed in last duty cycle. </param>
            <seealso cref="M:Adaptive.Agrona.Concurrent.IIdleStrategy.Idle(System.Int32)"></seealso>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.ControllableIdleStrategy.Idle">
            <summary>
            {@inheritDoc}
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.ControllableIdleStrategy.Reset">
            <summary>
            {@inheritDoc}
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.CountedErrorHandler">
            <summary>
            An <seealso cref="T:Adaptive.Agrona.ErrorHandler"/> which calls <seealso cref="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.Increment"/> before delegating the exception.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.CountedErrorHandler.#ctor(Adaptive.Agrona.ErrorHandler,Adaptive.Agrona.Concurrent.Status.AtomicCounter)">
            <summary>
            Construct a counted error handler with a delegate and counter.
            </summary>
            <param name="errorHandler"> to delegate to. </param>
            <param name="errorCounter"> to increment before delegation. </param>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog">
            <summary>
            Distinct record of error observations. Rather than grow a record indefinitely when many errors of the same type
            are logged, this log takes the approach of only recording distinct errors of the same type type and stack trace
            and keeping a count and time of observation so that the record only grows with new distinct observations.
            
            The provided <seealso cref="T:Adaptive.Agrona.Concurrent.IAtomicBuffer"/> can wrap a memory-mapped file so logging can be out of process. This provides
            the benefit that if a crash or lockup occurs then the log can be read externally without loss of data.
            
            This class is threadsafe to be used from multiple logging threads.
            
            The error records are recorded to the memory mapped buffer in the following format.
            
            <pre>
              0                   1                   2                   3
              0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |R|                         Length                              |
             +-+-------------------------------------------------------------+
             |R|                     Observation Count                       |
             +-+-------------------------------------------------------------+
             |R|                Last Observation Timestamp                   |
             |                                                               |
             +-+-------------------------------------------------------------+
             |R|               First Observation Timestamp                   |
             |                                                               |
             +---------------------------------------------------------------+
             |                     UTF-8 Encoded Error                      ...
            ...                                                              |
             +---------------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog.LengthOffset">
            <summary>
            Offset within a record at which the length field begins.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog.ObservationCountOffset">
            <summary>
            Offset within a record at which the observation count field begins.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog.LastObservationTimestampOffset">
            <summary>
            Offset within a record at which the last observation timestamp field begins.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog.FirstObservationTimestampOffset">
            <summary>
            Offset within a record at which the first observation timestamp field begins.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog.EncodedErrorOffset">
            <summary>
            Offset within a record at which the encoded exception field begins.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog.RecordAlignment">
            <summary>
            Alignment to be applied for record beginning.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog.#ctor(Adaptive.Agrona.Concurrent.IAtomicBuffer,Adaptive.Agrona.Concurrent.IEpochClock)">
            <summary>
            Create a new error log that will be written to a provided <seealso cref="T:Adaptive.Agrona.Concurrent.IAtomicBuffer"/>.
            </summary>
            <param name="buffer"> into which the observation records are recorded. </param>
            <param name="clock">  to be used for time stamping records. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog.Record(System.Exception)">
            <summary>
            Record an observation of an error. If it is the first observation of this error type for a stack trace
            then a new entry will be created. For subsequent observations of the same error type and stack trace a
            counter and time of last observation will be updated.
            </summary>
            <param name="observation"> to be logged as an error observation. </param>
            <returns> true if successfully logged otherwise false if insufficient space remaining in the log. </returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Errors.ErrorLogReader">
            <summary>
            Reader for the log created by a <seealso cref="T:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog"/>.
            
            The read methods are thread safe.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Errors.ErrorLogReader.HasErrors(Adaptive.Agrona.Concurrent.IAtomicBuffer)">
            <summary>
            Has the error buffer any recorded errors?
            </summary>
            <param name="buffer"> containing the <seealso cref="T:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog"/>. </param>
            <returns> true if there is at least one error. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Errors.ErrorLogReader.Read(Adaptive.Agrona.Concurrent.IAtomicBuffer,Adaptive.Agrona.Concurrent.Errors.ErrorConsumer)">
            <summary>
            Read all the errors in a log since the creation of the log.
            </summary>
            <param name="buffer">   containing the <seealso cref="T:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog"/>. </param>
            <param name="consumer"> to be called for each exception encountered. </param>
            <returns> the number of entries that has been read. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Errors.ErrorLogReader.Read(Adaptive.Agrona.Concurrent.IAtomicBuffer,Adaptive.Agrona.Concurrent.Errors.ErrorConsumer,System.Int64)">
            <summary>
            Read all the errors in a log since a given timestamp.
            </summary>
            <param name="buffer">         containing the <seealso cref="T:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog"/>. </param>
            <param name="consumer">       to be called for each exception encountered. </param>
            <param name="sinceTimestamp"> for filtering errors that have been recorded since this time. </param>
            <returns> the number of entries that has been read. </returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Errors.ErrorConsumer">
            <summary>
            Callback handler for consuming errors encountered in a <see cref="T:Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog"/>
            </summary>
            <param name="observationCount"> the number of times this distinct exception has been recorded.</param>
            <param name="firstObservationTimestamp"> time the first observation was recorded.</param>
            <param name="lastObservationTimestamp"> time the last observation was recorded.</param>
            <param name="encodedException"> String encoding of the exception and stack trace in UTF-8 format.</param>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Errors.LoggingErrorHandler">
            <summary>
            A logging <seealso cref="T:Adaptive.Agrona.ErrorHandler"/> that records to a <seealso cref="M:Adaptive.Agrona.Concurrent.Errors.LoggingErrorHandler.DistinctErrorLog"/> and if the log is full then overflows
            to a <seealso cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Errors.LoggingErrorHandler.#ctor(Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog)">
            <summary>
            Construct error handler wrapping a <seealso cref="M:Adaptive.Agrona.Concurrent.Errors.LoggingErrorHandler.DistinctErrorLog"/> with a default of <seealso cref="P:System.Console.Error"/> for the
            <seealso cref="M:Adaptive.Agrona.Concurrent.Errors.LoggingErrorHandler.ErrorOverflow"/>.
            </summary>
            <param name="log"> to wrap. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Errors.LoggingErrorHandler.#ctor(Adaptive.Agrona.Concurrent.Errors.DistinctErrorLog,System.IO.TextWriter)">
            <summary>
            Construct error handler wrapping a <seealso cref="M:Adaptive.Agrona.Concurrent.Errors.LoggingErrorHandler.DistinctErrorLog"/> and <seealso cref="T:System.IO.TextWriter"/> for error overflow.
            </summary>
            <param name="log">           to wrap. </param>
            <param name="errorOverflow"> to be used if the log fills. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Errors.LoggingErrorHandler.DistinctErrorLog">
            <summary>
            The wrapped log.
            </summary>
            <returns> the wrapped log. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Errors.LoggingErrorHandler.ErrorOverflow">
            <summary>
            The wrapped <seealso cref="T:System.IO.TextWriter"/> for error log overflow when the log is full.
            </summary>
            <returns> wrapped <seealso cref="T:System.IO.TextWriter"/> for error log overflow when the log is full. </returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.IAgent">
            <summary>
            An Agent is scheduled to do work on a thread on a duty cycle. Each Agent should have a defined role in a system.
            
            <see cref="M:Adaptive.Agrona.Concurrent.IAgent.OnStart"/>, <see cref="M:Adaptive.Agrona.Concurrent.IAgent.DoWork"/>, and <see cref="M:Adaptive.Agrona.Concurrent.IAgent.OnClose"/> will all be called by the same thread and in a
            threadsafe manner.
            
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAgent.OnStart">
            <summary>
            To be overridden by Agents that need to do resource init on start.
            
            This method will be called by the agent thread. It will only be called once.
            
            <b>Note:</b> Implementations of this method must be idempotent.
            
            In Java this is optional to implement (default method) C# doesn't have the same construct for interfaces.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAgent.DoWork">
            <summary>
            An agent should implement this method to do its work.
            
            The return value is used for implementing a backoff strategy that can be employed when no work is
            currently available for the agent to process.
            
            If the Agent should terminate and close then a <see cref="T:Adaptive.Agrona.Concurrent.AgentTerminationException"/> can be thrown.
            </summary>
            <returns> 0 to indicate no work was currently available, a positive value otherwise. </returns>
            <exception cref="T:System.Exception"> if an error has occurred </exception>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAgent.OnClose">
            <summary>
            To be overridden by Agents that need to do resource cleanup on close.
            
            This method will be called after the agent thread has terminated. It will only be called once by a single thread.
            
            <b>Note:</b> Implementations of this method must be idempotent.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAgent.RoleName">
            <summary>
            Get the name of this agent's role.
            </summary>
            <returns> the name of this agent's role. </returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.IAtomicBuffer">
            <summary>
            Abstraction over a range of buffer types that allows type to be accessed with memory ordering semantics.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.VerifyAlignment">
            <summary>
            Verify that the underlying buffer is correctly aligned to prevent word tearing and other ordering issues.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if the alignment is not correct. </exception>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.GetLongVolatile(System.Int32)">
            <summary>
            Get the value at a given index with volatile semantics.
            </summary>
            <param name="index"> in bytes from which to get. </param>
            <returns> the value for at a given index </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.PutLongVolatile(System.Int32,System.Int64)">
            <summary>
            Put a value to a given index with volatile semantics.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> for at a given index </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.PutLongOrdered(System.Int32,System.Int64)">
            <summary>
            Put a value to a given index with ordered store semantics.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> for at a given index </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.AddLongOrdered(System.Int32,System.Int64)">
            <summary>
            Add a value to a given index with ordered store semantics. Use a negative increment to decrement. </summary>
            <param name="index">     in bytes for where to put. </param>
            <param name="increment"> by which the value at the index will be adjusted. </param>
            <returns> the previous value at the index </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.CompareAndSetLong(System.Int32,System.Int64,System.Int64)">
            <summary>
            Atomic compare and set of a long given an expected value.
            </summary>
            <param name="index">         in bytes for where to put. </param>
            <param name="expectedValue"> at to be compared </param>
            <param name="updateValue">   to be exchanged </param>
            <returns> set successful or not </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.GetAndAddLong(System.Int32,System.Int64)">
            <summary>
            Atomically add a delta to a value at a location returning the previous contents.
            To decrement a negative delta can be provided.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="delta"> to be added to the value at the index </param>
            <returns> previous value </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.GetIntVolatile(System.Int32)">
            <summary>
            Get the value at a given index with volatile semantics.
            </summary>
            <param name="index"> in bytes from which to get. </param>
            <returns> the value for at a given index </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.PutIntVolatile(System.Int32,System.Int32)">
            <summary>
            Put a value to a given index with volatile semantics.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> for at a given index </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.PutIntOrdered(System.Int32,System.Int32)">
            <summary>
            Put a value to a given index with ordered semantics.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> for at a given index </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.AddIntOrdered(System.Int32,System.Int32)">
            <summary>
            Add a value to a given index with ordered store semantics. Use a negative increment to decrement. </summary>
            <param name="index">     in bytes for where to put. </param>
            <param name="increment"> by which the value at the index will be adjusted. </param>
            <returns> the previous value at the index </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.CompareAndSetInt(System.Int32,System.Int32,System.Int32)">
            <summary>
            Atomic compare and set of a int given an expected value.
            </summary>
            <param name="index">         in bytes for where to put. </param>
            <param name="expectedValue"> at to be compared </param>
            <param name="updateValue">   to be exchanged </param>
            <returns> successful or not </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.GetAndAddInt(System.Int32,System.Int32)">
            <summary>
            Atomically add a delta to a value at a location returning the previous contents.
            To decrement a negative delta can be provided.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="delta"> to be added to the value at the index </param>
            <returns> previous value </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.GetShortVolatile(System.Int32)">
            <summary>
            Get the value at a given index with volatile semantics.
            </summary>
            <param name="index"> in bytes from which to get. </param>
            <returns> the value for at a given index </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.PutShortVolatile(System.Int32,System.Int16)">
            <summary>
            Put a value to a given index with volatile semantics.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> for at a given index </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.GetByteVolatile(System.Int32)">
            <summary>
            Get the value at a given index with volatile semantics.
            </summary>
            <param name="index"> in bytes from which to get. </param>
            <returns> the value for at a given index </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IAtomicBuffer.PutByteVolatile(System.Int32,System.Byte)">
            <summary>
            Put a value to a given index with volatile semantics.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> for at a given index </param>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.IEpochClock">
            <summary>
            Retrieves the number of milliseconds since 1 Jan 1970 UTC.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IEpochClock.Time">
            <summary>
            Time in milliseconds since the 1 Jan 1970 UTC.
            </summary>
            <returns> the number of milliseconds since the 1 Jan 1970 UTC.</returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.IIdleStrategy">
            <summary>
            Idle strategy for use by threads when they do not have work to do.
            
            <h3>Note regarding implementor state</h3>
            
            Some implementations are known to be stateful, please note that you cannot safely assume implementations to be stateless.
            Where implementations are stateful it is recommended that implementation state is padded to avoid false sharing.
            
            <h3>Note regarding potential for TTSP(Time To Safe Point) issues</h3>
            
            If the caller spins in a 'counted' loop, and the implementation does not include a a safepoint poll this may cause a no
            (Time To SafePoint) problem. If this is the case for your application you can solve it by preventing the idle method from
            being inlined by setting the compilation symbol IDLESTRATEGY_NOINLINE.
            
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IIdleStrategy.Idle(System.Int32)">
            <summary>
            Perform current idle action (e.g. nothing/yield/sleep). This method signature expects users to call into it on every work
            'cycle'. The implementations may use the indication "workCount &gt; 0" to reset internal backoff state. This method works
            well with 'work' APIs which follow the following rules:
            <ul>
            <li>'work' returns a value larger than 0 when some work has been done</li>
            <li>'work' returns 0 when no work has been done</li>
            <li>'work' may return error codes which are less than 0, but which amount to no work has been done</li>
            </ul>
            
            Callers are expected to follow this pattern:
            
            <pre>
            <code>
            while (isRunning)
            {
                idleStrategy.Idle(doWork());
            }
            </code>
            </pre>
            
            </summary>
            <param name="workCount"> performed in last duty cycle. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IIdleStrategy.Idle">
            <summary>
            Perform current idle action (e.g. nothing/yield/sleep). To be used in conjunction with <seealso cref="M:Adaptive.Agrona.Concurrent.IIdleStrategy.Reset"/>
            to clear internal state when idle period is over (or before it begins). Callers are expected to follow this pattern:
            
            <pre>
            <code>
            while (isRunning)
            {
              if (!hasWork())
              {
                idleStrategy.Reset();
                while (!hasWork())
                {
                  if (!isRunning)
                  {
                    return;
                  }
                  idleStrategy.Idle();
                }
              }
              doWork();
            }
            </code>
            </pre>
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.IIdleStrategy.Reset">
            <summary>
            Reset the internal state in preparation for entering an idle state again.
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.INanoClock">
            <summary>
            Functional interface for return the current time as system wide monotonic tick of 1 nanosecond precision.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.INanoClock.NanoTime">
            <summary>
            The number of ticks in nanoseconds the clock has advanced since starting.
            </summary>
            <returns> number of ticks in nanoseconds the clock has advanced since starting.</returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.MessageHandler">
            <summary>
            Callback interface for processing of messages that are read from a buffer.
            Called for the processing of each message read from a buffer in turn.
            </summary>
            <param name="msgTypeId"> type of the encoded message.</param>
            <param name="buffer"> containing the encoded message.</param>
            <param name="index"> at which the encoded message begins.</param>
            <param name="length"> in bytes of the encoded message.</param>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.NoOpIdleStrategy">
            <summary>
            Low-latency idle strategy to be employed in loops that do significant work on each iteration such that any
            work in the idle strategy would be wasteful.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.NoOpIdleStrategy.Idle(System.Int32)">
            <summary>
            <b>Note</b>: this implementation will result in no safepoint poll once inlined.
            </summary>
            <seealso cref="T:Adaptive.Agrona.Concurrent.IIdleStrategy" />
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.NoOpIdleStrategy.Idle">
            <summary>
            <b>Note</b>: this implementation will result in no safepoint poll once inlined.
            </summary>
            <seealso cref="T:Adaptive.Agrona.Concurrent.IIdleStrategy" />
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.NullEpochClock">
            <inheritdoc />
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.NullEpochClock.Time">
            <inheritdoc />
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer">
            <summary>
            Ring-buffer for the concurrent exchanging of binary encoded messages from producer to consumer in a FIFO manner.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Capacity">
            <summary>
            Get the capacity of the ring-buffer in bytes for exchange.
            </summary>
            <returns> the capacity of the ring-buffer in bytes for exchange. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Write(System.Int32,Adaptive.Agrona.IDirectBuffer,System.Int32,System.Int32)">
            <summary>
            Non-blocking write of an message to an underlying ring-buffer.
            </summary>
            <param name="msgTypeId"> type of the message encoding. </param>
            <param name="srcBuffer"> containing the encoded binary message. </param>
            <param name="srcIndex"> at which the encoded message begins. </param>
            <param name="length"> of the encoded message in bytes. </param>
            <returns> true if written to the ring-buffer, or false if insufficient space exists. </returns>
            <exception cref="T:System.ArgumentException"> if the length is greater than <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.MaxMsgLength"/> </exception>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Read(Adaptive.Agrona.Concurrent.MessageHandler)">
            <summary>
            Read as many messages as are available from the ring buffer.
            </summary>
            <param name="handler"> to be called for processing each message in turn. </param>
            <returns> the number of messages that have been processed. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Read(Adaptive.Agrona.Concurrent.MessageHandler,System.Int32)">
            <summary>
            Read as many messages as are available from the ring buffer to up a supplied maximum.
            </summary>
            <param name="handler"> to be called for processing each message in turn. </param>
            <param name="messageCountLimit"> the number of messages will be read in a single invocation. </param>
            <returns> the number of messages that have been processed. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.MaxMsgLength">
            <summary>
            The maximum message length in bytes supported by the underlying ring buffer.
            </summary>
            <returns> the maximum message length in bytes supported by the underlying ring buffer. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.NextCorrelationId">
            <summary>
            Get the next value that can be used for a correlation id on an message when a response needs to be correlated.
            
            This method should be thread safe.
            </summary>
            <returns> the next value in the correlation sequence. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Buffer">
            <summary>
            Get the underlying buffer used by the RingBuffer for storage.
            </summary>
            <returns> the underlying buffer used by the RingBuffer for storage. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.ConsumerHeartbeatTime(System.Int64)">
            <summary>
            Set the time of the last consumer heartbeat.
            
            <b>Note:</b> The value for time must be valid across processes.
            </summary>
            <param name="time"> of the last consumer heartbeat. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.ConsumerHeartbeatTime">
            <summary>
            The time of the last consumer heartbeat.
            </summary>
            <returns> the time of the last consumer heartbeat. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.ProducerPosition">
            <summary>
            The position in bytes from start up of the producers.  The figure includes the headers.
            This is the range they are working with but could still be in the act of working with.
            </summary>
            <returns> number of bytes produced by the producers in claimed space. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.ConsumerPosition">
            <summary>
            The position in bytes from start up for the consumers.  The figure includes the headers.
            </summary>
            <returns> the count of bytes consumed by the consumers. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Size">
            <summary>
            Size of the buffer backlog in bytes between producers and consumers. The figure includes the size of headers.
            </summary>
            <returns> size of the backlog of bytes in the buffer between producers and consumers. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Unblock">
            <summary>
            Unblock a multi-producer ring buffer where a producer has died during the act of offering. The operation will
            scan from the consumer position up to the producer position.
            
            If no action is required at the position then none will be taken.
            </summary>
            <returns> true of an unblocking action was taken otherwise false. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.TryClaim(System.Int32,System.Int32)">
            <summary>
            Try to claim a space in the underlying ring-buffer into which a message can be written with zero copy semantics.
            Once the message has been written then <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Commit(System.Int32)"/> should be called thus making it available to be
            consumed. Alternatively a claim can be aborted using <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Abort(System.Int32)"/> method.
            <para>
            Claiming a space in the ring-buffer means that the consumer will not be able to consume past the claim until
            the claimed space is either committed or aborted. Producers will be able to write message even when outstanding
            claims exist.
            </para>
            <para>
            An example of using {@code TryClaim}:
            <pre>
            <code>
                final IRingBuffer ringBuffer = ...;
            
                final int index = ringBuffer.TryClaim(msgTypeId, messageLength);
                if (index > 0)
                {
                    try
                    {
                        final AtomicBuffer buffer = ringBuffer.Buffer();
                        // Work with the buffer directly using the index
                        ...
                    }
                    finally
                    {
                        ringBuffer.Commit(index); // commit message
                    }
                }
            </code>
            </pre>
            </para>
            <para>
            Ensure that claimed space is released even in case of an exception:
            <pre>
            <code>
                final IRingBuffer ringBuffer = ...;
            
                final int index = ringBuffer.TryClaim(msgTypeId, messageLength);
                if (index > 0)
                {
                    try
                    {
                        final IAtomicBuffer buffer = ringBuffer.buffer();
                        // Work with the buffer directly using the index
                        ...
                        ringBuffer.commit(index); // commit message
                    }
                    catch (final Throwable t)
                    {
                        ringBuffer.abort(index); // allow consumer to proceed
                        ...
                    }
                }
            </code>
            </pre>
            
            </para>
            </summary>
            <param name="msgTypeId"> type of the message encoding. Will be written into the header upon successful claim. </param>
            <param name="length">    of the claim in bytes. A claim length cannot be greater than <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.MaxMsgLength"/>. </param>
            <returns> a non-zero index into the underlying ring-buffer at which encoded message begins, otherwise returns
            <seealso cref="F:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.InsufficientCapacity"/> indicating that there is not enough free space in the buffer. </returns>
            <exception cref="T:System.ArgumentException"> if the {@code msgTypeId} is less than {@code 1}. </exception>
            <exception cref="T:System.InvalidOperationException"> if the {@code length} is negative or is greater than <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.MaxMsgLength"/>. </exception>
            <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Commit(System.Int32)"/>
            <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Abort(System.Int32)"/>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Commit(System.Int32)">
            <summary>
            Commit message that was written in the previously claimed space thus making it available to the consumer.
            </summary>
            <param name="index"> at which the encoded message begins, i.e. value returned from the <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.TryClaim(System.Int32,System.Int32)"/> call. </param>
            <exception cref="T:System.ArgumentException"> if the {@code index} is out of bounds. </exception>
            <exception cref="T:System.InvalidOperationException">    if this method is called after <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Commit(System.Int32)"/> or <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Abort(System.Int32)"/> was
                                             already invoked for the given {@code index}. </exception>
            <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.TryClaim(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Abort(System.Int32)">
            <summary>
            Abort claim and allow consumer to proceed after the claimed length. Aborting turns unused space into padding,
            i.e. changes type of the message to <seealso cref="F:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.PaddingMsgTypeId"/>.
            </summary>
            <param name="index"> at which the encoded message begins, i.e. value returned from the <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.TryClaim(System.Int32,System.Int32)"/> call. </param>
            <exception cref="T:System.ArgumentException"> if the {@code index} is out of bounds. </exception>
            <exception cref="T:System.InvalidOperationException">    if this method is called after <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Commit(System.Int32)"/> or <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.Abort(System.Int32)"/> was
                                             already invoked for the given {@code index}. </exception>
            <seealso cref="M:Adaptive.Agrona.Concurrent.RingBuffer.IRingBuffer.TryClaim(System.Int32,System.Int32)"/>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer">
            <summary>
            A ring-buffer that supports the exchange of messages from many producers to a single consumer.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.PaddingMsgTypeId">
            <summary>
            Record type is padding to prevent fragmentation in the buffer.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.InsufficientCapacity">
            <summary>
            Buffer has insufficient capacity to record a message.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.#ctor(Adaptive.Agrona.Concurrent.IAtomicBuffer)">
            <summary>
            Construct a new <seealso cref="N:Adaptive.Agrona.Concurrent.RingBuffer"/> based on an underlying <seealso cref="T:Adaptive.Agrona.Concurrent.IAtomicBuffer"/>.
            The underlying buffer must a power of 2 in size plus sufficient space
            for the <seealso cref="F:Adaptive.Agrona.Concurrent.RingBuffer.RingBufferDescriptor.TrailerLength"/>.
            </summary>
            <param name="buffer"> via which events will be exchanged. </param>
            <exception cref="T:System.InvalidOperationException"> if the buffer capacity is not a power of 2
            plus <seealso cref="F:Adaptive.Agrona.Concurrent.RingBuffer.RingBufferDescriptor.TrailerLength"/> in capacity. </exception>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.Capacity">
            <summary>
            Get the capacity of the ring-buffer in bytes for exchange.
            </summary>
            <returns> the capacity of the ring-buffer in bytes for exchange. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.Write(System.Int32,Adaptive.Agrona.IDirectBuffer,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.Read(Adaptive.Agrona.Concurrent.MessageHandler)">
            <summary>
            Read as many messages as are available from the ring buffer.
            </summary>
            <param name="handler"> to be called for processing each message in turn. </param>
            <returns> the number of messages that have been processed. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.Read(Adaptive.Agrona.Concurrent.MessageHandler,System.Int32)">
            <summary>
            Read as many messages as are available from the ring buffer to up a supplied maximum.
            </summary>
            <param name="handler"> to be called for processing each message in turn. </param>
            <param name="messageCountLimit"> the number of messages will be read in a single invocation. </param>
            <returns> the number of messages that have been processed. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.MaxMsgLength">
            <summary>
            The maximum message length in bytes supported by the underlying ring buffer.
            </summary>
            <returns> the maximum message length in bytes supported by the underlying ring buffer. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.NextCorrelationId">
            <summary>
            Get the next value that can be used for a correlation id on an message when a response needs to be correlated.
            
            This method should be thread safe.
            </summary>
            <returns> the next value in the correlation sequence. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.Buffer">
            <summary>
            Get the underlying buffer used by the RingBuffer for storage.
            </summary>
            <returns> the underlying buffer used by the RingBuffer for storage. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.ConsumerHeartbeatTime(System.Int64)">
            <summary>
            Set the time of the last consumer heartbeat.
            
            <b>Note:</b> The value for time must be valid across processes.
            </summary>
            <param name="time"> of the last consumer heartbeat. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.ConsumerHeartbeatTime">
            <summary>
            The time of the last consumer heartbeat.
            </summary>
            <returns> the time of the last consumer heartbeat. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.ProducerPosition">
            <summary>
            The position in bytes from start up of the producers.  The figure includes the headers.
            This is the range they are working with but could still be in the act of working with.
            </summary>
            <returns> number of bytes produced by the producers in claimed space. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.ConsumerPosition">
            <summary>
            The position in bytes from start up for the consumers.  The figure includes the headers.
            </summary>
            <returns> the count of bytes consumed by the consumers. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.Size">
            <summary>
            Size of the backlog of bytes in the buffer between producers and consumers. The figure includes the size of headers.
            </summary>
            <returns> size of the backlog of bytes in the buffer between producers and consumers. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.ManyToOneRingBuffer.Unblock">
            <inheritdoc />
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.RingBuffer.RecordDescriptor">
            <summary>
            Description of the record structure for message framing in the a <seealso cref="N:Adaptive.Agrona.Concurrent.RingBuffer"/>.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.RingBuffer.RecordDescriptor.HeaderLength">
            <summary>
            Header length made up of fields for length, type, and then the encoded message.
            <para>
            Writing of a positive record length signals the message recording is complete.
            <pre>
              0                   1                   2                   3
              0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |R|                         Length                              |
             +-+-------------------------------------------------------------+
             |                            Type                               |
             +---------------------------------------------------------------+
             |                       Encoded Message                        ...
            ...                                                              |
             +---------------------------------------------------------------+
            </pre>
            </para>
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.RingBuffer.RecordDescriptor.Alignment">
            <summary>
            Alignment as a multiple of bytes for each record.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.RecordDescriptor.LengthOffset(System.Int32)">
            <summary>
            The offset from the beginning of a record at which the message length field begins.
            </summary>
            <param name="recordOffset"> beginning index of the record. </param>
            <returns> offset from the beginning of a record at which the type field begins. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.RecordDescriptor.TypeOffset(System.Int32)">
            <summary>
            The offset from the beginning of a record at which the message type field begins.
            </summary>
            <param name="recordOffset"> beginning index of the record. </param>
            <returns> offset from the beginning of a record at which the type field begins. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.RecordDescriptor.EncodedMsgOffset(System.Int32)">
            <summary>
            The offset from the beginning of a record at which the encoded message begins.
            </summary>
            <param name="recordOffset"> beginning index of the record. </param>
            <returns> offset from the beginning of a record at which the encoded message begins. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.RecordDescriptor.RecordLength(System.Int64)">
            <summary>
            Extract the record length field from a word representing the header.
            </summary>
            <param name="header"> containing both fields. </param>
            <returns> the length field from the header. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.RecordDescriptor.CheckTypeId(System.Int32)">
            <summary>
            Check that and message id is in the valid range.
            </summary>
            <param name="msgTypeId"> to be checked. </param>
            <exception cref="T:System.ArgumentException"> if the id is not in the valid range. </exception>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.RingBuffer.RingBufferDescriptor">
            <summary>
            Layout description for the underlying buffer used by a <seealso cref="N:Adaptive.Agrona.Concurrent.RingBuffer"/>. The buffer consists
            of a ring of messages which is a power of 2 in size, followed by a trailer section containing state
            information for the producers and consumers of the ring.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.RingBuffer.RingBufferDescriptor.TailPositionOffset">
            <summary>
            Offset within the trailer for where the tail value is stored. 
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.RingBuffer.RingBufferDescriptor.HeadCachePositionOffset">
            <summary>
            Offset within the trailer for where the head cache value is stored. 
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.RingBuffer.RingBufferDescriptor.HeadPositionOffset">
            <summary>
            Offset within the trailer for where the head value is stored. 
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.RingBuffer.RingBufferDescriptor.CorrelationCounterOffset">
            <summary>
            Offset within the trailer for where the correlation counter value is stored. 
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.RingBuffer.RingBufferDescriptor.ConsumerHeartbeatOffset">
            <summary>
            Offset within the trailer for where the consumer heartbeat time value is stored. 
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.RingBuffer.RingBufferDescriptor.TrailerLength">
            <summary>
            Total length of the trailer in bytes. 
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.RingBuffer.RingBufferDescriptor.CheckCapacity(System.Int32)">
            <summary>
            Check the the buffer capacity is the correct size (a power of 2 + <seealso cref="F:Adaptive.Agrona.Concurrent.RingBuffer.RingBufferDescriptor.TrailerLength"/>).
            </summary>
            <param name="capacity"> to be checked. </param>
            <exception cref="T:System.InvalidOperationException"> if the buffer capacity is incorrect. </exception>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.ShutdownSignalBarrier">
            <summary>
            One time barrier for blocking one or more threads until a SIGINT or SIGTERM signal is received from the operating
            system or by programmatically calling <seealso cref="M:Adaptive.Agrona.Concurrent.ShutdownSignalBarrier.Signal"/>. Useful for shutting down a service.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.ShutdownSignalBarrier.Signal">
            <summary>
            Programmatically signal awaiting threads.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.ShutdownSignalBarrier.Await">
            <summary>
            Await the reception of the shutdown signal.
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.SleepingIdleStrategy">
            <summary>
            When idle this strategy is to sleep for a specified period.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.SleepingIdleStrategy.#ctor(System.Int32)">
            <summary>
            Constructed a new strategy that will sleep for a given period when idle.
            </summary>
            <param name="sleepPeriodMs"> period in millisecond for which the strategy will sleep when work count is 0. </param>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.SpinWaitIdleStrategy">
            <summary>
            <see cref="T:Adaptive.Agrona.Concurrent.IIdleStrategy"/> which uses a <see cref="T:System.Threading.SpinWait"/>.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.StatusIndicator.SetOrdered(System.Int64)">
            <summary>
            Sets the current status indication of the component with ordered atomic memory semantics.
            </summary>
            <param name="value"> the current status indication of the component. </param>
        </member>
        <member name="P:Adaptive.Agrona.Concurrent.StatusIndicatorReader.Id">
            <summary>
            Identifier for this status indicator.
            </summary>
            <value> the identifier for this status indicator. </value>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.StatusIndicatorReader.GetVolatile">
            <summary>
            Get the current status indication of a component with volatile semantics.
            </summary>
            <returns> the current status indication of a component with volatile semantics. </returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Status.AtomicCounter">
            <summary>
            Atomic counter that is backed by an <seealso cref="T:Adaptive.Agrona.Concurrent.IAtomicBuffer"/> that can be read across threads and processes.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.#ctor(Adaptive.Agrona.Concurrent.IAtomicBuffer,System.Int32)">
            <summary>
            Map a counter over a buffer. This version will NOT free the counter on close.
            </summary>
            <param name="buffer">    containing the counter. </param>
            <param name="counterId"> identifier of the counter. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.#ctor(Adaptive.Agrona.Concurrent.IAtomicBuffer,System.Int32,Adaptive.Agrona.Concurrent.Status.CountersManager)">
            <summary>
            Map a counter over a buffer. This version will free the counter on close.
            </summary>
            <param name="buffer">          containing the counter. </param>
            <param name="counterId">       identifier for the counter. </param>
            <param name="countersManager"> to be called to free the counter on close. </param>
        </member>
        <member name="P:Adaptive.Agrona.Concurrent.Status.AtomicCounter.Id">
            <summary>
            Identity for the counter within the <seealso cref="T:Adaptive.Agrona.Concurrent.Status.CountersManager"/>.
            </summary>
            <returns> identity for the counter within the <seealso cref="T:Adaptive.Agrona.Concurrent.Status.CountersManager"/>. </returns>
        </member>
        <member name="P:Adaptive.Agrona.Concurrent.Status.AtomicCounter.IsClosed">
            <summary>
            Has this counter been closed?
            </summary>
            <returns> true if this counter has already been closed. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.Increment">
            <summary>
            Perform an atomic increment that will not lose updates across threads.
            </summary>
            <returns> the previous value of the counter </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.IncrementOrdered">
            <summary>
            Perform an atomic increment that is not safe across threads.
            </summary>
            <returns> the previous value of the counter </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.Set(System.Int64)">
            <summary>
            Set the counter with volatile semantics.
            </summary>
            <param name="value"> to be set with volatile semantics. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.SetOrdered(System.Int64)">
            <summary>
            Set the counter with ordered semantics.
            </summary>
            <param name="value"> to be set with ordered semantics. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.GetAndAdd(System.Int64)">
            <summary>
            Add an increment to the counter that will not lose updates across threads.
            </summary>
            <param name="increment"> to be added. </param>
            <returns> the previous value of the counter </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.GetAndAddOrdered(System.Int64)">
            <summary>
            Add an increment to the counter with ordered store semantics.
            </summary>
            <param name="increment"> to be added with ordered store semantics. </param>
            <returns> the previous value of the counter </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.CompareAndSet(System.Int64,System.Int64)">
            <summary>
            Compare the current value to expected and if true then set to the update value atomically.
            </summary>
            <param name="expectedValue"> for the counter. </param>
            <param name="updateValue">   for the counter. </param>
            <returns> true if successful otherwise false. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.Get">
            <summary>
            Get the latest value for the counter with volatile semantics.
            </summary>
            <returns> the latest value for the counter. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.GetWeak">
            <summary>
            Get the value of the counter using weak ordering semantics. This is the same a standard read of a field.
            </summary>
            <returns> the  value for the counter. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.AtomicCounter.Dispose">
            <summary>
            Free the counter slot for reuse.
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Status.CountersManager">
            <summary>
            Manages the allocation and freeing of counters that are normally stored in a memory-mapped file.
            
            This class in not threadsafe. Counters should be centrally managed.
            
            <b>Values Buffer</b>
            <pre>
              0                   1                   2                   3
              0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |                        Counter Value                          |
             |                                                               |
             +---------------------------------------------------------------+
             |                     120 bytes of padding                     ...
            ...                                                              |
             +---------------------------------------------------------------+
             |                   Repeats to end of buffer                   ...
             |                                                               |
            ...                                                              |
             +---------------------------------------------------------------+
            </pre>
            
            <b>Meta Data Buffer</b>
            <pre>
              0                   1                   2                   3
              0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |                        Record State                           |
             +---------------------------------------------------------------+
             |                          Type Id                              |
             +---------------------------------------------------------------+
             |                   Free-for-reuse Deadline                     |
             |                                                               |
             +---------------------------------------------------------------+
             |                      112 bytes for key                       ...
            ...                                                              |
             +-+-------------------------------------------------------------+
             |R|                      Label Length                           |
             +-+-------------------------------------------------------------+
             |                      380 bytes of Label                      ...
            ...                                                              |
             +---------------------------------------------------------------+
             |                   Repeats to end of buffer                   ...
             |                                                               |
            ...                                                              |
             +---------------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersManager.DEFAULT_TYPE_ID">
            <summary>
            Default type id of a counter when none is supplied.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersManager.#ctor(Adaptive.Agrona.Concurrent.IAtomicBuffer,Adaptive.Agrona.Concurrent.IAtomicBuffer,System.Text.Encoding,Adaptive.Agrona.Concurrent.IEpochClock,System.Int64)">
            <summary>
            Create a new counter buffer manager over two buffers.
            </summary>
            <param name="metaDataBuffer">       containing the types, keys, and labels for the counters. </param>
            <param name="valuesBuffer">         containing the values of the counters themselves. </param>
            <param name="labelCharset">         for the label encoding. </param>
            <param name="epochClock">           to use for determining time for keep counter from being reused after being freed. </param>
            <param name="freeToReuseTimeoutMs"> timeout (in milliseconds) to keep counter from being reused after being freed. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersManager.#ctor(Adaptive.Agrona.Concurrent.IAtomicBuffer,Adaptive.Agrona.Concurrent.IAtomicBuffer)">
            <summary>
            Create a new counter buffer manager over two buffers.
            </summary>
            <param name="metaDataBuffer"> containing the types, keys, and labels for the counters. </param>
            <param name="valuesBuffer">   containing the values of the counters themselves. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersManager.#ctor(Adaptive.Agrona.Concurrent.IAtomicBuffer,Adaptive.Agrona.Concurrent.IAtomicBuffer,System.Text.Encoding)">
            <summary>
            Create a new counter buffer manager over two buffers.
            </summary>
            <param name="metaDataBuffer"> containing the types, keys, and labels for the counters. </param>
            <param name="valuesBuffer">   containing the values of the counters themselves. </param>
            <param name="labelCharset">   for the label encoding. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersManager.Allocate(System.String,System.Int32)">
            <summary>
            Allocate a new counter with a given label and type.
            </summary>
            <param name="label">  to describe the counter. </param>
            <param name="typeId"> for the type of counter. </param>
            <returns> the id allocated for the counter. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersManager.Allocate(System.String,System.Int32,System.Action{Adaptive.Agrona.IMutableDirectBuffer})">
            <summary>
            Allocate a new counter with a given label.
            
            The key function will be called with a buffer with the exact length of available key space
            in the record for the user to store what they want for the key. No offset is required.
            </summary>
            <param name="label">   to describe the counter. </param>
            <param name="typeId">  for the type of counter. </param>
            <param name="keyFunc"> for setting the key value for the counter. </param>
            <returns> the id allocated for the counter. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersManager.Allocate(System.Int32,Adaptive.Agrona.IDirectBuffer,System.Int32,System.Int32,Adaptive.Agrona.IDirectBuffer,System.Int32,System.Int32)">
            <summary>
            Allocate a counter with the minimum of allocation by allowing the label an key to be provided and copied.
            <para>
            If the keyBuffer is null then a copy of the key is not attempted.
               
            </para>
            </summary>
            <param name="typeId">      for the counter. </param>
            <param name="keyBuffer">   containing the optional key for the counter. </param>
            <param name="keyOffset">   within the keyBuffer at which the key begins. </param>
            <param name="keyLength">   of the key in the keyBuffer. </param>
            <param name="labelBuffer"> containing the mandatory label for the counter. </param>
            <param name="labelOffset"> within the labelBuffer at which the label begins. </param>
            <param name="labelLength"> of the label in the labelBuffer. </param>
            <returns> the id allocated for the counter. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersManager.NewCounter(System.String)">
            <summary>
            Allocate a counter record and wrap it with a new <seealso cref="T:Adaptive.Agrona.Concurrent.Status.AtomicCounter"/> for use with a default type
            of <see cref="F:Adaptive.Agrona.Concurrent.Status.CountersManager.DEFAULT_TYPE_ID"/>
            </summary>
            <param name="label"> to describe the counter. </param>
            <returns> a newly allocated <seealso cref="T:Adaptive.Agrona.Concurrent.Status.AtomicCounter"/> </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersManager.NewCounter(System.String,System.Int32)">
            <summary>
            Allocate a counter record and wrap it with a new <seealso cref="T:Adaptive.Agrona.Concurrent.Status.AtomicCounter"/> for use.
            </summary>
            <param name="label">  to describe the counter. </param>
            <param name="typeId"> for the type of counter. </param>
            <returns> a newly allocated <seealso cref="T:Adaptive.Agrona.Concurrent.Status.AtomicCounter"/> </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersManager.NewCounter(System.String,System.Int32,System.Action{Adaptive.Agrona.IMutableDirectBuffer})">
            <summary>
            Allocate a counter record and wrap it with a new <seealso cref="T:Adaptive.Agrona.Concurrent.Status.AtomicCounter"/> for use.
            </summary>
            <param name="label">   to describe the counter. </param>
            <param name="typeId">  for the type of counter. </param>
            <param name="keyFunc"> for setting the key value for the counter.</param>
            <returns> a newly allocated <seealso cref="T:Adaptive.Agrona.Concurrent.Status.AtomicCounter"/> </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersManager.NewCounter(System.Int32,Adaptive.Agrona.IDirectBuffer,System.Int32,System.Int32,Adaptive.Agrona.IDirectBuffer,System.Int32,System.Int32)">
            <summary>
            Allocate a counter record and wrap it with a new <seealso cref="T:Adaptive.Agrona.Concurrent.Status.AtomicCounter"/> for use.
            <para>
            If the keyBuffer is null then a copy of the key is not attempted.
            
            </para>
            </summary>
            <param name="typeId">      for the counter. </param>
            <param name="keyBuffer">   containing the optional key for the counter. </param>
            <param name="keyOffset">   within the keyBuffer at which the key begins. </param>
            <param name="keyLength">   of the key in the keyBuffer. </param>
            <param name="labelBuffer"> containing the mandatory label for the counter. </param>
            <param name="labelOffset"> within the labelBuffer at which the label begins. </param>
            <param name="labelLength"> of the label in the labelBuffer. </param>
            <returns> the id allocated for the counter. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersManager.Free(System.Int32)">
            <summary>
            Free the counter identified by counterId.
            </summary>
            <param name="counterId"> the counter to freed </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersManager.SetCounterValue(System.Int32,System.Int64)">
            <summary>
            Set an <seealso cref="T:Adaptive.Agrona.Concurrent.Status.AtomicCounter"/> value based on counterId.
            </summary>
            <param name="counterId"> to be set. </param>
            <param name="value">     to set for the counter. </param>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Status.CountersReader">
            <summary>
            Reads the counters metadata and values buffers.
            
            This class is threadsafe and can be used across threads.
            
            <b>Values Buffer</b>
            <pre>
              0                   1                   2                   3
              0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |                        Counter Value                          |
             |                                                               |
             +---------------------------------------------------------------+
             |                     120 bytes of padding                     ...
            ...                                                              |
             +---------------------------------------------------------------+
             |                   Repeats to end of buffer                   ...
             |                                                               |
            ...                                                              |
             +---------------------------------------------------------------+
            </pre>
            
            <b>Meta Data Buffer</b>
            <pre>
              0                   1                   2                   3
              0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |                        Record State                           |
             +---------------------------------------------------------------+
             |                          Type Id                              |
             +---------------------------------------------------------------+
             |                   Free-for-reuse Deadline                     |
             |                                                               |
             +---------------------------------------------------------------+
             |                      112 bytes for key                       ...
            ...                                                              |
             +-+-------------------------------------------------------------+
             |R|                      Label Length                           |
             +-+-------------------------------------------------------------+
             |                      380 bytes of Label                      ...
            ...                                                              |
             +---------------------------------------------------------------+
             |                   Repeats to end of buffer                   ...
             |                                                               |
            ...                                                              |
             +---------------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Status.CountersReader.MetaData">
            <summary>
            Accept a metadata record.
            </summary>
            <param name="counterId"> of the counter.</param>
            <param name="typeId"> of the counter.</param>
            <param name="keyBuffer"> for the counter.</param>
            <param name="label"> for the counter.</param>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Status.CountersReader.CounterConsumer">
            <summary>
            Callback function for consuming basic counter details and value.
            </summary>
            <param name="value">     of the counter. </param>
            <param name="counterId"> of the counter </param>
            <param name="label">     for the counter. </param>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.NULL_COUNTER_ID">
            <summary>
            Can be used to representing a null counter id when passed as a argument.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.RECORD_UNUSED">
            <summary>
            Record has not been used.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.RECORD_ALLOCATED">
            <summary>
            Record currently allocated for use.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.RECORD_RECLAIMED">
            <summary>
            Record was active and now has been reclaimed.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.NOT_FREE_TO_REUSE">
            <summary>
            Deadline to indicate counter is not free to be reused.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.TYPE_ID_OFFSET">
            <summary>
            Offset in the record at which the type id field is stored.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.FREE_FOR_REUSE_DEADLINE_OFFSET">
            <summary>
            Offset in the record at which the deadline (in milliseconds) for when counter may be reused.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.KEY_OFFSET">
            <summary>
            Offset in the record at which the key is stored.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.LABEL_OFFSET">
            <summary>
            Offset in the record at which the label is stored.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.FULL_LABEL_LENGTH">
            <summary>
            Length of a counter label length including length prefix.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.MAX_LABEL_LENGTH">
            <summary>
            Maximum length of a label not including its length prefix.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.MAX_KEY_LENGTH">
            <summary>
            Maximum length a key can be.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.METADATA_LENGTH">
            <summary>
            Length of a meta data record in bytes.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.Status.CountersReader.COUNTER_LENGTH">
            <summary>
            Length of the space allocated to a counter that includes padding to avoid false sharing.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersReader.#ctor(Adaptive.Agrona.Concurrent.IAtomicBuffer,Adaptive.Agrona.Concurrent.IAtomicBuffer)">
            <summary>
            Construct a reader over buffers containing the values and associated metadata.
            
            Counter labels default to <see cref="P:System.Text.Encoding.UTF8"/>
            
            </summary>
            <param name="metaDataBuffer"> containing the counter metadata. </param>
            <param name="valuesBuffer">   containing the counter values. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersReader.#ctor(Adaptive.Agrona.Concurrent.IAtomicBuffer,Adaptive.Agrona.Concurrent.IAtomicBuffer,System.Text.Encoding)">
            <summary>
            Construct a reader over buffers containing the values and associated metadata.
            
            </summary>
            <param name="metaDataBuffer"> containing the counter metadata. </param>
            <param name="valuesBuffer">   containing the counter values. </param>
            <param name="encoding"> for the label encoding</param>
        </member>
        <member name="P:Adaptive.Agrona.Concurrent.Status.CountersReader.MaxCounterId">
            <summary>
            Get the maximum counter id which can be supported given the length of the values buffer.
            </summary>
            <returns> the maximum counter id which can be supported given the length of the values buffer. </returns>
        </member>
        <member name="P:Adaptive.Agrona.Concurrent.Status.CountersReader.MetaDataBuffer">
            <summary>
            Get the buffer containing the metadata for the counters.
            </summary>
            <returns> the buffer containing the metadata for the counters. </returns>
        </member>
        <member name="P:Adaptive.Agrona.Concurrent.Status.CountersReader.ValuesBuffer">
            <summary>
            Get the buffer containing the values for the counters.
            </summary>
            <returns> the buffer containing the values for the counters. </returns>
        </member>
        <member name="P:Adaptive.Agrona.Concurrent.Status.CountersReader.LabelCharset">
            <summary>
            The <see cref="T:System.Text.Encoding"/> used for the encoded label.
            </summary>
            <returns> the <see cref="T:System.Text.Encoding"/> used for the encoded label.</returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersReader.CounterOffset(System.Int32)">
            <summary>
            The offset in the counter buffer for a given counterId.
            </summary>
            <param name="counterId"> for which the offset should be provided. </param>
            <returns> the offset in the counter buffer. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersReader.MetaDataOffset(System.Int32)">
            <summary>
            The offset in the metadata buffer for a given id.
            </summary>
            <param name="counterId"> for the record. </param>
            <returns> the offset at which the metadata record begins. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersReader.ForEach(Adaptive.Agrona.Collections.IntObjConsumer{System.String})">
            <summary>
            Iterate over all labels in the label buffer.
            </summary>
            <param name="consumer"> function to be called for each label. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersReader.ForEach(Adaptive.Agrona.Concurrent.Status.CountersReader.CounterConsumer)">
            <summary>
            Iterate over the counters and provide the value and basic metadata.
            </summary>
            <param name="consumer"> for each allocated counter. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersReader.ForEach(Adaptive.Agrona.Concurrent.Status.CountersReader.MetaData)">
            <summary>
            Iterate over all the metadata in the buffer.
            </summary>
            <param name="metaData"> function to be called for each metadata record. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersReader.GetCounterValue(System.Int32)">
            <summary>
            Get the value for a given counter id as a volatile read.
            </summary>
            <param name="counterId"> to be read. </param>
            <returns> the current value of the counter. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersReader.GetCounterState(System.Int32)">
            <summary>
            Get the state for a given counter id as a volatile read.
            </summary>
            <param name="counterId"> to be read. </param>
            <returns> the current state of the counter. </returns>
            <seealso cref="F:Adaptive.Agrona.Concurrent.Status.CountersReader.RECORD_UNUSED"></seealso>
            <seealso cref="F:Adaptive.Agrona.Concurrent.Status.CountersReader.RECORD_ALLOCATED"></seealso>
            <seealso cref="F:Adaptive.Agrona.Concurrent.Status.CountersReader.RECORD_RECLAIMED"></seealso>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersReader.GetCounterTypeId(System.Int32)">
            <summary>
            Get the type id for a given counter id.
            </summary>
            <param name="counterId"> to be read. </param>
            <returns> the type id for a given counter id. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersReader.GetFreeForReuseDeadline(System.Int32)">
            <summary>
            Get the deadline (in milliseconds) for when a given counter id may be reused.
            </summary>
            <param name="counterId"> to be read. </param>
            <returns> deadline (in milliseconds) for when a given counter id may be reused or <seealso cref="F:Adaptive.Agrona.Concurrent.Status.CountersReader.NOT_FREE_TO_REUSE"/> if
            currently in use. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.CountersReader.GetCounterLabel(System.Int32)">
            <summary>
            Get the label for a given counter id.
            </summary>
            <param name="counterId"> to be read. </param>
            <returns> the label for the given counter id. </returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Status.IPosition">
            <summary>
            Reports on how far through a buffer some component has progressed.
            
            Threadsafe to write to from a single writer.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.IPosition.Get">
            <summary>
            Get the current position of a component without memory ordering semantics.
            </summary>
            <returns> the current position of a component </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.IPosition.Set(System.Int64)">
            <summary>
            Sets the current position of the component without memory ordering semantics.
            </summary>
            <param name="value"> the current position of the component. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.IPosition.SetOrdered(System.Int64)">
            <summary>
            Sets the current position of the component with ordered memory semantics.
            </summary>
            <param name="value"> the current position of the component. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.IPosition.SetVolatile(System.Int64)">
            <summary>
            Sets the current position of the component with volatile memory semantics.
            </summary>
            <param name="value"> the current position of the component. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.IPosition.ProposeMax(System.Int64)">
            <summary>
            Set the position to a new proposedValue if greater than the current value with memory ordering semantics.
            </summary>
            <param name="proposedValue"> for the new max. </param>
            <returns> true if a new max as been set otherwise false. </returns>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.IPosition.ProposeMaxOrdered(System.Int64)">
            <summary>
            Set the position to the new proposedValue if greater than the current value with memory ordering semantics.
            </summary>
            <param name="proposedValue"> for the new max. </param>
            <returns> true if a new max as been set otherwise false. </returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Status.IReadablePosition">
            <summary>
            Indicates how far through an abstract task a component has progressed as a counter value.
            </summary>
        </member>
        <member name="P:Adaptive.Agrona.Concurrent.Status.IReadablePosition.Id">
            <summary>
            Identifier for this position.
            </summary>
            <value> the identifier for this position. </value>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.IReadablePosition.GetVolatile">
            <summary>
            Get the current position of a component with volatile semantics
            </summary>
            <returns> the current position of a component with volatile semantics </returns>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.Status.UnsafeBufferPosition">
            <summary>
            Reports a position by recording it in an <seealso cref="T:Adaptive.Agrona.Concurrent.UnsafeBuffer"/>.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.UnsafeBufferPosition.#ctor(Adaptive.Agrona.Concurrent.UnsafeBuffer,System.Int32)">
            <summary>
            Map a position over a buffer.
            </summary>
            <param name="buffer">    containing the counter. </param>
            <param name="counterId"> identifier of the counter. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.Status.UnsafeBufferPosition.#ctor(Adaptive.Agrona.Concurrent.UnsafeBuffer,System.Int32,Adaptive.Agrona.Concurrent.Status.CountersManager)">
            <summary>
            Map a position over a buffer and this indicator owns the counter for reclamation.
            </summary>
            <param name="buffer">          containing the counter. </param>
            <param name="counterId">       identifier of the counter. </param>
            <param name="countersManager"> to be used for freeing the counter when this is closed. </param>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.UnsafeBuffer">
            <summary>
            Supports regular, byte ordered, and atomic (memory ordered) access to an underlying buffer.
            The buffer can be a byte[] or an unmanaged buffer.
            
            <seealso cref="T:Adaptive.Agrona.ByteOrder"/> of a wrapped buffer is not applied to the <seealso cref="T:Adaptive.Agrona.Concurrent.UnsafeBuffer"/>; <seealso cref="T:Adaptive.Agrona.Concurrent.UnsafeBuffer"/>s are
            stateless and can be used concurrently. To control <seealso cref="T:Adaptive.Agrona.ByteOrder"/> use the appropriate accessor method
            with the <seealso cref="T:Adaptive.Agrona.ByteOrder"/> overload.
            
            Note: This class has a natural ordering that is inconsistent with equals.
            Types my be different but equal on buffer contents.
            
            Note: The wrap methods on this class are not thread safe. Concurrent access should only happen after a successful wrap.
            </summary>
        </member>
        <member name="F:Adaptive.Agrona.Concurrent.UnsafeBuffer.ALIGNMENT">
            <summary>
            Buffer alignment to ensure atomic word accesses.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.UnsafeBuffer.#ctor(System.Byte[])">
            <summary>
            Attach a view to a byte[] for providing direct access.
            </summary>
            <param name="buffer"> to which the view is attached. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.UnsafeBuffer.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Attach a view to a byte[] for providing direct access.
            </summary>
            <param name="buffer"> to which the view is attached. </param>
            <param name="offset"> within the buffer to begin. </param>
            <param name="length"> of the buffer to be included. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.UnsafeBuffer.#ctor(Adaptive.Agrona.ByteBuffer)">
            <summary>
            Attach a view to a bytebuffer for providing direct access.
            </summary>
            <param name="buffer"> to which the view is attached. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.UnsafeBuffer.#ctor(Adaptive.Agrona.IDirectBuffer)">
            <summary>
            Attach a view to an existing <seealso cref="T:Adaptive.Agrona.IDirectBuffer"/>
            </summary>
            <param name="buffer"> to which the view is attached. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.UnsafeBuffer.#ctor(Adaptive.Agrona.IDirectBuffer,System.Int32,System.Int32)">
            <summary>
            Attach a view to an existing <seealso cref="T:Adaptive.Agrona.IDirectBuffer"/>
            </summary>
            <param name="buffer"> to which the view is attached. </param>
            <param name="offset"> within the buffer to begin. </param>
            <param name="length"> of the buffer to be included. </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.UnsafeBuffer.#ctor(System.IntPtr,System.Int32)">
            <summary>
            Attach a view to an off-heap memory region by address.
            </summary>
            <param name="address"> where the memory begins off-heap </param>
            <param name="length">  of the buffer from the given address </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.UnsafeBuffer.#ctor(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Attach a view to an off-heap memory region by address.
            </summary>
            <param name="address"> where the memory begins off-heap </param>
            <param name="offset"></param>
            <param name="length">  of the buffer from the given address </param>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.UnsafeBuffer.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Adaptive.Agrona.Concurrent.UnsafeBuffer.Finalize">
            <summary>
            Destructor for <see cref="T:Adaptive.Agrona.Concurrent.UnsafeBuffer"/>
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.Concurrent.YieldingIdleStrategy">
            <summary>
            <seealso cref="T:Adaptive.Agrona.Concurrent.IIdleStrategy"/> that will call <seealso cref="M:System.Threading.Thread.Yield"/> when the work count is zero.
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.DelegatingErrorHandler">
            <summary>
            <seealso cref="T:Adaptive.Agrona.ErrorHandler"/> that can insert into a chain of responsibility so it handles an error and then delegates
            on to the next in the chain. This allows for taking action pre or post invocation of the next delegate.
            <para>
            Implementations are responsible for calling the next in the chain.
            </para>
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.DelegatingErrorHandler.Next(Adaptive.Agrona.ErrorHandler)">
            <summary>
            Set the next <seealso cref="T:Adaptive.Agrona.ErrorHandler"/> to be called in a chain.
            </summary>
            <param name="errorHandler"> the next <seealso cref="T:Adaptive.Agrona.ErrorHandler"/> to be called in a chain. </param>
        </member>
        <member name="M:Adaptive.Agrona.DelegatingErrorHandler.OnError(System.Exception)">
            <summary>
            Callback to notify of an error that has occurred when processing an operation or event.
            
            This method is assumed non-throwing, so rethrowing the exception or triggering further exceptions would be a bug.
            
            <param name="exception"> exception that occurred while processing an operation or event.</param>
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.EndianessConverter">
            <summary>
            Utility class to manipulate endianess 
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.EndianessConverter.ApplyInt16(Adaptive.Agrona.ByteOrder,System.Int16)">
            <summary>
            Applies the specified endianess to an int16 (reverse bytes if input endianess is different from system's endianess)
            </summary>
            <param name="byteOrder">the endianess to apply</param>
            <param name="value">the value to be converted</param>
            <returns>The value with applied endianess</returns>
        </member>
        <member name="M:Adaptive.Agrona.EndianessConverter.ApplyUint16(Adaptive.Agrona.ByteOrder,System.UInt16)">
            <summary>
            Applies the specified endianess to an uint16 (reverse bytes if input endianess is different from system's endianess)
            </summary>
            <param name="byteOrder">the endianess to apply</param>
            <param name="value">the value to be converted</param>
            <returns>The value with applied endianess</returns>
        </member>
        <member name="M:Adaptive.Agrona.EndianessConverter.ApplyInt32(Adaptive.Agrona.ByteOrder,System.Int32)">
            <summary>
            Applies the specified endianess to an int32 (reverse bytes if input endianess is different from system's endianess)
            </summary>
            <param name="byteOrder">the endianess to apply</param>
            <param name="value">the value to be converted</param>
            <returns>The value with applied endianess</returns>
        </member>
        <member name="M:Adaptive.Agrona.EndianessConverter.ApplyUint32(Adaptive.Agrona.ByteOrder,System.UInt32)">
            <summary>
            Applies the specified endianess to an uint32 (reverse bytes if input endianess is different from system's endianess)
            </summary>
            <param name="byteOrder">the endianess to apply</param>
            <param name="value">the value to be converted</param>
            <returns>The value with applied endianess</returns>
        </member>
        <member name="M:Adaptive.Agrona.EndianessConverter.ApplyUint64(Adaptive.Agrona.ByteOrder,System.UInt64)">
            <summary>
            Applies the specified endianess to an uint64 (reverse bytes if input endianess is different from system's endianess)
            </summary>
            <param name="byteOrder">the endianess to apply</param>
            <param name="value">the value to be converted</param>
            <returns>The value with applied endianess</returns>
        </member>
        <member name="M:Adaptive.Agrona.EndianessConverter.ApplyInt64(Adaptive.Agrona.ByteOrder,System.Int64)">
            <summary>
            Applies the specified endianess to an int64 (reverse bytes if input endianess is different from system's endianess)
            </summary>
            <param name="byteOrder">the endianess to apply</param>
            <param name="value">the value to be converted</param>
            <returns>The value with applied endianess</returns>
        </member>
        <member name="M:Adaptive.Agrona.EndianessConverter.ApplyDouble(Adaptive.Agrona.ByteOrder,System.Double)">
            <summary>
            Applies the specified endianess to a double (reverse bytes if input endianess is different from system's endianess)
            </summary>
            <param name="byteOrder">the endianess to apply</param>
            <param name="value">the value to be converted</param>
            <returns>The value with applied endianess</returns>
        </member>
        <member name="M:Adaptive.Agrona.EndianessConverter.ApplyFloat(Adaptive.Agrona.ByteOrder,System.Single)">
            <summary>
            Applies the specified endianess to an float (reverse bytes if input endianess is different from system's endianess)
            </summary>
            <param name="byteOrder">the endianess to apply</param>
            <param name="value">the value to be converted</param>
            <returns>The value with applied endianess</returns>
        </member>
        <member name="T:Adaptive.Agrona.ErrorHandler">
            <summary>
            Callback to notify of an error that has occurred when processing an operation or event.
            
            This method is assumed non-throwing, so rethrowing the exception or triggering further exceptions would be a bug.
            
            <param name="exception"> exception that occurred while processing an operation or event.</param>
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.IDirectBuffer">
            <summary>
            Abstraction over a range of buffer types that allows fields to be read in native typed fashion.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.Wrap(System.Byte[])">
            <summary>
            Attach a view to a byte[] for providing direct access.
            </summary>
            <param name="buffer"> to which the view is attached. </param>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.Wrap(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Attach a view to a byte[] for providing direct access.
            </summary>
            <param name="buffer"> to which the view is attached. </param>
            <param name="offset"> at which the view begins. </param>
            <param name="length"> of the buffer included in the view </param>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.Wrap(Adaptive.Agrona.IDirectBuffer)">
            <summary>
            Attach a view to an existing <seealso cref="T:Adaptive.Agrona.IDirectBuffer"/>
            </summary>
            <param name="buffer"> to which the view is attached. </param>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.Wrap(Adaptive.Agrona.IDirectBuffer,System.Int32,System.Int32)">
            <summary>
            Attach a view to a <seealso cref="T:Adaptive.Agrona.IDirectBuffer"/> for providing direct access.
            </summary>
            <param name="buffer"> to which the view is attached. </param>
            <param name="offset"> at which the view begins. </param>
            <param name="length"> of the buffer included in the view </param>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.Wrap(System.IntPtr,System.Int32)">
            <summary>
            Attach a view to an off-heap memory region by address.
            </summary>
            <param name="pointer"> where the memory begins off-heap </param>
            <param name="length">  of the buffer from the given address </param>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.Wrap(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Attach a view to an off-heap memory region by address.
            </summary>
            <param name="pointer"> where the memory begins off-heap </param>
            <param name="offset"> at which the view begins. </param>
            <param name="length">  of the buffer from the given address </param>
        </member>
        <member name="P:Adaptive.Agrona.IDirectBuffer.BufferPointer">
            <summary>
            A pointer to the underlying buffer.
            </summary>
        </member>
        <member name="P:Adaptive.Agrona.IDirectBuffer.ByteArray">
            <summary>
            Get the underlying byte[] if one exists
            </summary>
        </member>
        <member name="P:Adaptive.Agrona.IDirectBuffer.ByteBuffer">
            <summary>
            Get the underlying <see cref="P:Adaptive.Agrona.IDirectBuffer.ByteBuffer"/> if one exists
            </summary>
        </member>
        <member name="P:Adaptive.Agrona.IDirectBuffer.Capacity">
            <summary>
            Get the capacity of the underlying buffer.
            </summary>
            <returns> the capacity of the underlying buffer in bytes. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.CheckLimit(System.Int32)">
            <summary>
            Check that a given limit is not greater than the capacity of a buffer from a given offset.
            <para>
            Can be overridden in a DirectBuffer subclass to enable an extensible buffer or handle retry after a flush.
            
            </para>
            </summary>
            <param name="limit"> up to which access is required. </param>
            <exception cref="T:System.IndexOutOfRangeException"> if limit is beyond buffer capacity. </exception>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetLong(System.Int32)">
            <summary>
            Get the value at a given index.
            </summary>
            <param name="index"> in bytes from which to get. </param>
            <returns> the value for at a given index </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetInt(System.Int32)">
            <summary>
            Get the value at a given index.
            </summary>
            <param name="index"> in bytes from which to get. </param>
            <returns> the value for at a given index </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetDouble(System.Int32)">
            <summary>
            Get the value at a given index.
            </summary>
            <param name="index"> in bytes from which to get. </param>
            <returns> the value at a given index. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetFloat(System.Int32)">
            <summary>
            Get the value at a given index.
            </summary>
            <param name="index"> in bytes from which to get. </param>
            <returns> the value at a given index. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetShort(System.Int32)">
            <summary>
            Get the value at a given index.
            </summary>
            <param name="index"> in bytes from which to get. </param>
            <returns> the value at a given index. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetChar(System.Int32)">
            <summary>
            Get the value at a given index.
            </summary>
            <param name="index"> in bytes from which to get. </param>
            <returns> the value at a given index. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetByte(System.Int32)">
            <summary>
            Get the value at a given index.
            </summary>
            <param name="index"> in bytes from which to get. </param>
            <returns> the value at a given index. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetBytes(System.Int32,System.Byte[])">
            <summary>
            Get from the underlying buffer into a supplied byte array.
            This method will try to fill the supplied byte array.
            </summary>
            <param name="index"> in the underlying buffer to start from. </param>
            <param name="dst">   into which the dst will be copied. </param>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetBytes(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get bytes from the underlying buffer into a supplied byte array.
            </summary>
            <param name="index">  in the underlying buffer to start from. </param>
            <param name="dst">    into which the bytes will be copied. </param>
            <param name="offset"> in the supplied buffer to start the copy </param>
            <param name="length"> of the supplied buffer to use. </param>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetBytes(System.Int32,Adaptive.Agrona.IMutableDirectBuffer,System.Int32,System.Int32)">
            <summary>
            Get bytes from this <seealso cref="T:Adaptive.Agrona.IDirectBuffer"/> into the provided <seealso cref="T:Adaptive.Agrona.IMutableDirectBuffer"/> at given indices. </summary>
            <param name="index">     in this buffer to begin getting the bytes. </param>
            <param name="dstBuffer"> to which the bytes will be copied. </param>
            <param name="dstIndex">  in the channel buffer to which the byte copy will begin. </param>
            <param name="length">    of the bytes to be copied. </param>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetStringUtf8(System.Int32)">
            <summary>
            Get a String from bytes encoded in UTF-8 format that is length prefixed.
            </summary>
            <param name="index">    at which the String begins. </param>
            <returns> the String as represented by the UTF-8 encoded bytes. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetStringAscii(System.Int32)">
            <summary>
            Get a String from bytes encoded in ASCII format that is length prefixed.
            </summary>
            <param name="index">    at which the String begins. </param>
            <returns> the String as represented by the ASCII encoded bytes. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetStringAscii(System.Int32,System.Text.StringBuilder)">
            <summary>
            Get a String from bytes encoded in ASCII format that is length prefixed and append to an <seealso cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="index">      at which the String begins. </param>
            <param name="appendable"> to append the chars to. </param>
            <returns> the number of bytes copied. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetStringAscii(System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Get part of a String from bytes encoded in ASCII format that is length prefixed and append to an
            <seealso cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="index">      at which the String begins. </param>
            <param name="length">     of the String in bytes to decode. </param>
            <param name="appendable"> to append the chars to. </param>
            <returns> the number of bytes copied. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetStringUtf8(System.Int32,System.Int32)">
            <summary>
            Get part of String from bytes encoded in UTF-8 format that is length prefixed.
            </summary>
            <param name="index"> at which the String begins. </param>
            <param name="length"> of the String in bytes to decode. </param>
            <returns> the String as represented by the UTF-8 encoded bytes. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetStringAscii(System.Int32,System.Int32)">
            <summary>
            Get part of String from bytes encoded in ASCII format that is length prefixed.
            </summary>
            <param name="index"> at which the String begins. </param>
            <param name="length"> of the String in bytes to decode. </param>
            <returns> the String as represented by the ASCII encoded bytes. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetStringWithoutLengthUtf8(System.Int32,System.Int32)">
            <summary>
            Get an encoded UTF-8 String from the buffer that does not have a length prefix.
            </summary>
            <param name="index"> at which the String begins. </param>
            <param name="length"> of the String in bytes to decode. </param>
            <returns> the String as represented by the UTF-8 encoded bytes. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.GetStringWithoutLengthAscii(System.Int32,System.Int32)">
            <summary>
            Get an encoded ASCII String from the buffer that does not have a length prefix.
            </summary>
            <param name="index">  at which the String begins. </param>
            <param name="length"> of the String in bytes to decode. </param>
            <returns> the String as represented by the Ascii encoded bytes. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IDirectBuffer.BoundsCheck(System.Int32,System.Int32)">
            <summary>
            Check that a given length of bytes is within the bounds from a given index.
            </summary>
            <param name="index">  from which to check. </param>
            <param name="length"> in bytes of the range to check. </param>
            <exception cref="T:System.IndexOutOfRangeException"> if the length goes outside of the capacity range. </exception>
        </member>
        <member name="M:Adaptive.Agrona.IErrorHandler.OnError(System.Exception)">
            <summary>
            Callback to notify of an error that has occurred when processing an operation or event.
            
            This method is assumed non-throwing, so rethrowing the exception or triggering further exceptions would be a bug.
            
            <param name="exception"> exception that occurred while processing an operation or event.</param>
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.IManagedResource">
            <summary>
            Implementations of this interface can a resource that need to have external state tracked for deletion.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.IManagedResource.TimeOfLastStateChange(System.Int64)">
            <summary>
            Set the time of the last state change.
            </summary>
            <param name="time"> of the last state change. </param>
        </member>
        <member name="M:Adaptive.Agrona.IManagedResource.TimeOfLastStateChange">
            <summary>
            Get the time of the last state change.
            </summary>
            <returns> the time of the last state change. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IManagedResource.Delete">
            <summary>
            Delete any resources held. This method should be idempotent.
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.IMutableDirectBuffer">
            <summary>
            Abstraction over a range of buffer types that allows fields to be written in native typed fashion.
            </summary>
        </member>
        <member name="P:Adaptive.Agrona.IMutableDirectBuffer.IsExpandable">
            <summary>
            Is this buffer expandable to accommodate putting data into it beyond the current capacity?
            </summary>
            <returns> true is the underlying storage can expand otherwise false. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.SetMemory(System.Int32,System.Int32,System.Byte)">
            <summary>
            Set a region of memory to a given byte value.
            </summary>
            <param name="index">  at which to start. </param>
            <param name="length"> of the run of bytes to set. </param>
            <param name="value">  the memory will be set to. </param>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutLong(System.Int32,System.Int64)">
            <summary>
            Put a value to a given index.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> for at a given index </param>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutInt(System.Int32,System.Int32)">
            <summary>
            Put a value to a given index.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> for at a given index </param>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutIntAscii(System.Int32,System.Int32)">
            <summary>
            Puts an ASCII encoded int into the buffer
            </summary>
            <param name="index"> the offset at which to put the int </param>
            <param name="value"> the int to write </param>
            <returns> the number of bytes that the int took up encoded </returns>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutLongAscii(System.Int32,System.Int64)">
            <summary>
            Puts an ASCII encoded long integer into the buffer
            </summary>
            <param name="index"> the offset at which to put the int </param>
            <param name="value"> the int to write </param>
            <returns> the number of bytes that the int took up encoded </returns>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutDouble(System.Int32,System.Double)">
            <summary>
            Put a value to a given index.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> to be written </param>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutFloat(System.Int32,System.Single)">
            <summary>
            Put a value to a given index.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> to be written </param>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutShort(System.Int32,System.Int16)">
            <summary>
            Put a value to a given index.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> to be written </param>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutChar(System.Int32,System.Char)">
            <summary>
            Put a value to a given index.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> to be written </param>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutByte(System.Int32,System.Byte)">
            <summary>
            Put a value to a given index.
            </summary>
            <param name="index"> in bytes for where to put. </param>
            <param name="value"> to be written </param>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutBytes(System.Int32,System.Byte[])">
            <summary>
            Put an array of src into the underlying buffer.
            </summary>
            <param name="index"> in the underlying buffer to start from. </param>
            <param name="src">   to be copied to the underlying buffer. </param>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutBytes(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Put an array into the underlying buffer.
            </summary>
            <param name="index">  in the underlying buffer to start from. </param>
            <param name="src">    to be copied to the underlying buffer. </param>
            <param name="offset"> in the supplied buffer to begin the copy. </param>
            <param name="length"> of the supplied buffer to copy. </param>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutBytes(System.Int32,Adaptive.Agrona.IDirectBuffer,System.Int32,System.Int32)">
            <summary>
            Put bytes from a source <seealso cref="T:Adaptive.Agrona.IDirectBuffer"/> into this <seealso cref="T:Adaptive.Agrona.IMutableDirectBuffer"/> at given indices.
            </summary>
            <param name="index">     in this buffer to begin putting the bytes. </param>
            <param name="srcBuffer"> from which the bytes will be copied. </param>
            <param name="srcIndex">  in the source buffer from which the byte copy will begin. </param>
            <param name="length">    of the bytes to be copied. </param>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutStringUtf8(System.Int32,System.String)">
            <summary>
            Encode a String as UTF-8 bytes to the buffer with a length prefix.
            </summary>
            <param name="index"> at which the String should be encoded. </param>
            <param name="value">  of the String to be encoded. </param>
            <returns> the number of bytes put to the buffer. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutStringAscii(System.Int32,System.String)">
            <summary>
            Encode a String as ASCII bytes to the buffer with a length prefix.
            </summary>
            <param name="index"> at which the String should be encoded. </param>
            <param name="value">  of the String to be encoded. </param>
            <returns> the number of bytes put to the buffer. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutStringWithoutLengthAscii(System.Int32,System.String)">
            <summary>
            Encode a String as ASCII bytes in the buffer without a length prefix.
            </summary>
            <param name="index"> at which the String begins. </param>
            <param name="value"> of the String to be encoded. </param>
            <returns> the number of bytes encoded. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutStringWithoutLengthAscii(System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Encode a String as ASCII bytes in the buffer without a length prefix taking a range of the value.
            </summary>
            <param name="index">       at which the String begins. </param>
            <param name="value">       of the String to be encoded. </param>
            <param name="valueOffset"> in the value String to begin. </param>
            <param name="length">      of the value String to encode. If this is greater than valueOffset - value length then the
                               lesser will be used. </param>
            <returns> the number of bytes encoded. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutStringUtf8(System.Int32,System.String,System.Int32)">
            <summary>
            Encode a String as UTF-8 bytes the buffer with a length prefix with a maximum encoded size check.
            </summary>
            <param name="index">          at which the String should be encoded. </param>
            <param name="value">          of the String to be encoded. </param>
            <param name="maxEncodedSize"> to be checked before writing to the buffer. </param>
            <returns> the number of bytes put to the buffer. </returns>
            <exception cref="T:System.ArgumentException"> if the encoded bytes are greater than maxEncodedSize. </exception>
        </member>
        <member name="M:Adaptive.Agrona.IMutableDirectBuffer.PutStringWithoutLengthUtf8(System.Int32,System.String)">
            <summary>
            Encode a String as UTF-8 bytes in the buffer without a length prefix.
            </summary>
            <param name="index"> at which the String begins. </param>
            <param name="value"> of the String to be encoded. </param>
            <returns> the number of bytes encoded. </returns>
        </member>
        <member name="M:Adaptive.Agrona.IoUtil.MapExistingFile(System.String,Adaptive.Agrona.MapMode)">
            <summary>
            Check that file exists, open file, and return <seealso cref="T:Adaptive.Agrona.Util.MappedByteBuffer"/> for entire file
            </summary>
            <param name="path"> of the file to map </param>
            <param name="mapMode"></param>
            <returns> <seealso cref="T:Adaptive.Agrona.Util.MappedByteBuffer"/> for the file </returns>
        </member>
        <member name="M:Adaptive.Agrona.IoUtil.MapExistingFile(System.IO.FileInfo,System.Int64,System.Int64)">
            <summary>
            Check that file exists, open file, and return <seealso cref="T:Adaptive.Agrona.Util.MappedByteBuffer"/> for entire file
            </summary>
            <param name="path"> of the file to map </param>
            <param name="offset"></param>
            <param name="length"></param>
            <returns> <seealso cref="T:Adaptive.Agrona.Util.MappedByteBuffer"/> for the file </returns>
        </member>
        <member name="M:Adaptive.Agrona.IoUtil.OpenMemoryMappedFile(System.String)">
            <summary>
            Check that file exists and open file
            </summary>
            <param name="path"> of the file to map </param>
            <returns> <seealso cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile"/> the file </returns>
        </member>
        <member name="M:Adaptive.Agrona.IoUtil.MapExistingFile(System.IO.FileStream)">
            <summary>
            Return MappedByteBuffer for entire file
            <para>
            The file itself will be closed, but the mapping will persist.
            
            </para>
            </summary>
            <param name="fileStream">         of the file to map </param>
            <returns> <seealso cref="T:Adaptive.Agrona.Util.MappedByteBuffer"/> for the file </returns>
        </member>
        <member name="M:Adaptive.Agrona.IoUtil.MapExistingFile(System.IO.FileInfo,System.String)">
            <summary>
            Check that file exists, open file, and return MappedByteBuffer for entire file
            <para>
            The file itself will be closed, but the mapping will persist.
            
            </para>
            </summary>
            <param name="location">         of the file to map </param>
            <param name="descriptionLabel"> to be associated for any exceptions </param>
            <returns> <seealso cref="T:Adaptive.Agrona.Util.MappedByteBuffer"/> for the file </returns>
        </member>
        <member name="M:Adaptive.Agrona.IoUtil.Unmap(Adaptive.Agrona.Util.MappedByteBuffer)">
            <summary>
            Unmap a <seealso cref="T:Adaptive.Agrona.Util.MappedByteBuffer"/> without waiting for the next GC cycle.
            </summary>
            <param name="wrapper"> to be unmapped. </param>
        </member>
        <member name="M:Adaptive.Agrona.IoUtil.CheckFileExists(System.IO.FileInfo,System.String)">
            <summary>
            Check that a file exists and throw an exception if not.
            </summary>
            <param name="file"> to check existence of. </param>
            <param name="name"> to associate for the exception </param>
        </member>
        <member name="M:Adaptive.Agrona.IoUtil.CheckFileExists(System.String)">
            <summary>
            Check that a file exists and throw an exception if not.
            </summary>
            <param name="path"> to check existence of. </param>
        </member>
        <member name="T:Adaptive.Agrona.MarkFile">
            <summary>
            Interface for managing Command-n-Control files.
            
            The assumptions are: (1) the version field is an int in size, (2) the timestamp field is a long in size,
            and (3) the version field comes before the timestamp field.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.MarkFile.#ctor(System.IO.DirectoryInfo,System.String,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int64,Adaptive.Agrona.Concurrent.IEpochClock,System.Action{System.Int32},System.Action{System.String})">
            <summary>
            Create a CnC directory and file if none present. Checking if an active CnC file exists and is active. Old CnC
            file is deleted and recreated if not active.
            
            Total length of CnC file will be mapped until <seealso cref="M:Adaptive.Agrona.MarkFile.Dispose"/> is called.
            </summary>
            <param name="directory">             for the CnC file </param>
            <param name="filename">              of the CnC file </param>
            <param name="warnIfDirectoryExists"> for logging purposes </param>
            <param name="dirDeleteOnStart">      if desired </param>
            <param name="versionFieldOffset">    to use for version field access </param>
            <param name="timestampFieldOffset">  to use for timestamp field access </param>
            <param name="totalFileLength">       to allocate when creating new CnC file </param>
            <param name="timeoutMs">             for the activity check (in milliseconds) </param>
            <param name="epochClock">            to use for time checks </param>
            <param name="versionCheck">          to use for existing CnC file and version field </param>
            <param name="logger">                to use to signal progress or null </param>
        </member>
        <member name="M:Adaptive.Agrona.MarkFile.#ctor(System.IO.FileInfo,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int64,Adaptive.Agrona.Concurrent.IEpochClock,System.Action{System.Int32},System.Action{System.String})">
            <summary>
            Create a CnC file if none present. Checking if an active CnC file exists and is active. Existing CnC file
            is used if not active.
            
            Total length of CnC file will be mapped until <seealso cref="M:Adaptive.Agrona.MarkFile.Dispose"/> is called.
            </summary>
            <param name="markFile">               to use </param>
            <param name="shouldPreExist">        or not </param>
            <param name="versionFieldOffset">    to use for version field access </param>
            <param name="timestampFieldOffset">  to use for timestamp field access </param>
            <param name="totalFileLength">       to allocate when creating new CnC file </param>
            <param name="timeoutMs">             for the activity check (in milliseconds) </param>
            <param name="epochClock">            to use for time checks </param>
            <param name="versionCheck">          to use for existing CnC file and version field </param>
            <param name="logger">                to use to signal progress or null </param>
        </member>
        <member name="M:Adaptive.Agrona.MarkFile.#ctor(System.IO.DirectoryInfo,System.String,System.Int32,System.Int32,System.Int64,Adaptive.Agrona.Concurrent.IEpochClock,System.Action{System.Int32},System.Action{System.String})">
            <summary>
            Map a pre-existing CnC file if one present and is active.
            
            Total length of CnC file will be mapped until <seealso cref="M:Adaptive.Agrona.MarkFile.Dispose"/> is called.
            </summary>
            <param name="directory">             for the CnC file </param>
            <param name="filename">              of the CnC file </param>
            <param name="versionFieldOffset">    to use for version field access </param>
            <param name="timestampFieldOffset">  to use for timestamp field access </param>
            <param name="timeoutMs">             for the activity check (in milliseconds) and for how long to wait for file to exist </param>
            <param name="epochClock">            to use for time checks </param>
            <param name="versionCheck">          to use for existing CnC file and version field </param>
            <param name="logger">                to use to signal progress or null </param>
        </member>
        <member name="M:Adaptive.Agrona.MarkFile.#ctor(Adaptive.Agrona.Util.MappedByteBuffer,System.Int32,System.Int32)">
            <summary>
            Manage a CnC file given a mapped file and offsets of version and timestamp.
            
            If mappedCncBuffer is not null, then it will be unmapped upon <seealso cref="M:Adaptive.Agrona.MarkFile.Dispose"/>.
            </summary>
            <param name="mappedBuffer">      for the CnC fields </param>
            <param name="versionFieldOffset">   for the version field </param>
            <param name="timestampFieldOffset"> for the timestamp field </param>
        </member>
        <member name="M:Adaptive.Agrona.MarkFile.#ctor(Adaptive.Agrona.Concurrent.UnsafeBuffer,System.Int32,System.Int32)">
            <summary>
            Manage a CnC file given a buffer and offsets of version and timestamp.
            </summary>
            <param name="buffer">            for the CnC fields </param>
            <param name="versionFieldOffset">   for the version field </param>
            <param name="timestampFieldOffset"> for the timestamp field </param>
        </member>
        <member name="T:Adaptive.Agrona.SBE.ICompositeDecoderFlyweight">
            <summary>
            A flyweight for decoding an SBE Composite type.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.SBE.ICompositeDecoderFlyweight.Wrap(Adaptive.Agrona.IDirectBuffer,System.Int32)">
            <summary>
            Wrap a buffer for decoding at a given offset.
            </summary>
            <param name="buffer"> containing the encoded SBE Composite type. </param>
            <param name="offset"> at which the encoded SBE Composite type begins. </param>
            <returns> the <seealso cref="T:Adaptive.Agrona.SBE.ICompositeDecoderFlyweight"/> for fluent API design. </returns>
        </member>
        <member name="T:Adaptive.Agrona.SBE.ICompositeEncoderFlyweight">
            <summary>
            A flyweight for encoding an SBE Composite type.
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.SBE.IDecoderFlyweight">
            <summary>
            A flyweight for decoding an SBE type.
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.SBE.IEncoderFlyweight">
            <summary>
            A flyweight for encoding an SBE type.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.SBE.IEncoderFlyweight.Wrap(Adaptive.Agrona.IMutableDirectBuffer,System.Int32)">
            <summary>
            Wrap a buffer for encoding at a given offset.
            </summary>
            <param name="buffer"> to be wrapped and into which the type will be encoded. </param>
            <param name="offset"> at which the encoded object will be begin. </param>
            <returns> the <seealso cref="T:Adaptive.Agrona.SBE.IEncoderFlyweight"/> for fluent API design. </returns>
        </member>
        <member name="T:Adaptive.Agrona.SBE.IFlyweight">
            <summary>
            An SBE (Simple Binary Encoding) flyweight object.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.SBE.IFlyweight.EncodedLength">
            <summary>
            The length of the encoded type in bytes.
            </summary>
            <returns> the length of the encoded type in bytes. </returns>
        </member>
        <member name="T:Adaptive.Agrona.SBE.IMessageDecoderFlyweight">
            <summary>
            A flyweight for decoding an SBE message from a buffer.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.SBE.IMessageDecoderFlyweight.Wrap(Adaptive.Agrona.IDirectBuffer,System.Int32,System.Int32,System.Int32)">
            <summary>
            Wrap a buffer containing an encoded message for decoding.
            </summary>
            <param name="buffer">            containing the encoded message. </param>
            <param name="offset">            in the buffer at which the decoding should begin. </param>
            <param name="actingBlockLength"> the root block length the decoder should act on. </param>
            <param name="actingVersion">     the version of the encoded message. </param>
            <returns> the <seealso cref="T:Adaptive.Agrona.SBE.IMessageDecoderFlyweight"/> for fluent API design. </returns>
        </member>
        <member name="T:Adaptive.Agrona.SBE.IMessageEncoderFlyweight">
            <summary>
            A flyweight for encoding SBE messages.
            </summary>
        </member>
        <member name="T:Adaptive.Agrona.SBE.IMessageFlyweight">
            <summary>
            Common behaviour to SBE Message encoder and decoder flyweights.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.SBE.IMessageFlyweight.SbeBlockLength">
            <summary>
            The length of the root block in bytes.
            </summary>
            <returns> the length of the root block in bytes. </returns>
        </member>
        <member name="M:Adaptive.Agrona.SBE.IMessageFlyweight.SbeTemplateId">
            <summary>
            The SBE template identifier for the message.
            </summary>
            <returns> the SBE template identifier for the message. </returns>
        </member>
        <member name="M:Adaptive.Agrona.SBE.IMessageFlyweight.SbeSchemaId">
            <summary>
            The SBE Schema identifier containing the message declaration.
            </summary>
            <returns> the SBE Schema identifier containing the message declaration. </returns>
        </member>
        <member name="M:Adaptive.Agrona.SBE.IMessageFlyweight.SbeSchemaVersion">
            <summary>
            The version number of the SBE Schema containing the message.
            </summary>
            <returns> the version number of the SBE Schema containing the message. </returns>
        </member>
        <member name="M:Adaptive.Agrona.SBE.IMessageFlyweight.SbeSemanticType">
            <summary>
            The semantic type of the message which is typically the semantic equivalent in the FIX repository.
            </summary>
            <returns> the semantic type of the message which is typically the semantic equivalent in the FIX repository. </returns>
        </member>
        <member name="M:Adaptive.Agrona.SBE.IMessageFlyweight.Offset">
            <summary>
            The current offset in the buffer from which the message is being encoded or decoded.
            </summary>
            <returns> the current offset in the buffer from which the message is being encoded or decoded. </returns>
        </member>
        <member name="T:Adaptive.Agrona.SemanticVersion">
            <summary>
            Store and extract a semantic version in a 4 byte integer.
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.SemanticVersion.Compose(System.Int32,System.Int32,System.Int32)">
            <summary>
            Compose a 4-byte integer with major, minor, and patch version stored in the least significant 3 bytes.
            The sum of the components must be greater than zero.
            </summary>
            <param name="major"> version in the range 0-255. </param>
            <param name="minor"> version in the range 0-255 </param>
            <param name="patch"> version in the range 0-255. </param>
            <returns> the semantic version made from the three components. </returns>
            <exception cref="T:System.ArgumentException"> if the values are outside acceptable range. </exception>
        </member>
        <member name="M:Adaptive.Agrona.SemanticVersion.Major(System.Int32)">
            <summary>
            Get the major version from a composite value.
            </summary>
            <param name="version"> as a composite from which to extract the major version. </param>
            <returns> the major version value. </returns>
        </member>
        <member name="M:Adaptive.Agrona.SemanticVersion.Minor(System.Int32)">
            <summary>
            Get the minor version from a composite value.
            </summary>
            <param name="version"> as a composite from which to extract the minor version. </param>
            <returns> the minor version value. </returns>
        </member>
        <member name="M:Adaptive.Agrona.SemanticVersion.Patch(System.Int32)">
            <summary>
            Get the patch version from a composite value.
            </summary>
            <param name="version"> as a composite from which to extract the patch version. </param>
            <returns> the patch version value. </returns>
        </member>
        <member name="M:Adaptive.Agrona.SemanticVersion.ToString(System.Int32)">
            <summary>
            Generate a <seealso cref="T:System.String"/> representation of the semantic version in the format {@code major.minor.patch}.
            </summary>
            <param name="version"> to be converted to a string. </param>
            <returns> the <seealso cref="T:System.String"/> representation of the semantic version in the format {@code major.minor.patch}. </returns>
        </member>
        <member name="M:Adaptive.Agrona.SystemUtil.ParseSize(System.String,System.String)">
            <summary>
            Parse a string representation of a value with optional suffix of 'g', 'm', and 'k' suffix to indicate
            gigabytes, megabytes, or kilobytes respectively.
            </summary>
            <param name="propertyName">  that associated with the size value. </param>
            <param name="propertyValue"> to be parsed. </param>
            <returns> the long value. </returns>
            <exception cref="T:System.FormatException"> if the value is out of range or mal-formatted. </exception>
        </member>
        <member name="M:Adaptive.Agrona.SystemUtil.ParseDuration(System.String,System.String)">
            <summary>
            Parse a string representation of a time duration with an optional suffix of 's', 'ms', 'us', or 'ns' to
            indicate seconds, milliseconds, microseconds, or nanoseconds respectively.
            <para>
            If the resulting duration is greater than <seealso cref="F:System.Int64.MaxValue"/> then <seealso cref="F:System.Int64.MaxValue"/> is used.
            
            </para>
            </summary>
            <param name="propertyName">  associated with the duration value. </param>
            <param name="propertyValue"> to be parsed. </param>
            <returns> the long value. </returns>
            <exception cref="T:System.FormatException"> if the value is negative or malformed. </exception>
        </member>
        <member name="T:Adaptive.Agrona.Util.ByteUtil">
            <summary>
            Utility to copy blocks of memory
            </summary>
        </member>
        <member name="M:Adaptive.Agrona.Util.IntUtil.NumberOfTrailingZeros(System.Int32)">
            <summary>
            Returns the number of zero bits following the lowest-order ("rightmost")
            one-bit in the two's complement binary representation of the specified
            {@code int} value.  Returns 32 if the specified value has no
            one-bits in its two's complement representation, in other words if it is
            equal to zero.
            </summary>
            <param name="i"> the value whose number of trailing zeros is to be computed </param>
            <returns> the number of zero bits following the lowest-order ("rightmost")
                one-bit in the two's complement binary representation of the
                specified {@code int} value, or 32 if the value is equal
                to zero.
            @since 1.5 </returns>
        </member>
        <member name="M:Adaptive.Agrona.Util.IntUtil.NumberOfLeadingZeros(System.Int32)">
            <summary>
            Note Olivier: Direct port of the Java method Integer.NumberOfLeadingZeros
            
            Returns the number of zero bits preceding the highest-order
            ("leftmost") one-bit in the two's complement binary representation
            of the specified {@code int} value.  Returns 32 if the
            specified value has no one-bits in its two's complement representation,
            in other words if it is equal to zero.
            
            <para>Note that this method is closely related to the logarithm base 2.
            For all positive {@code int} values x:
            <ul>
            <li>floor(log<sub>2</sub>(x)) = {@code 31 - numberOfLeadingZeros(x)}</li>
            <li>ceil(log<sub>2</sub>(x)) = {@code 32 - numberOfLeadingZeros(x - 1)}</li>
            </ul>
            
            </para>
            </summary>
            <param name="i"> the value whose number of leading zeros is to be computed </param>
            <returns> the number of zero bits preceding the highest-order
                ("leftmost") one-bit in the two's complement binary representation
                of the specified {@code int} value, or 32 if the value
                is equal to zero.
            </returns>
        </member>
        <member name="T:Adaptive.Agrona.Util.LockSupport">
            <summary>
            Mimic Java class LockSupport
            </summary>
        </member>
    </members>
</doc>
